diff --git a/usr/palm/applications/com.palm.app.email/app/controllers/message-assistant.js b/usr/palm/applications/com.palm.app.email/app/controllers/message-assistant.js
index 567c7a1..f07d8ba 100644
--- a/usr/palm/applications/com.palm.app.email/app/controllers/message-assistant.js
+++ b/usr/palm/applications/com.palm.app.email/app/controllers/message-assistant.js
@@ -68,10 +68,10 @@ var MessageAssistant = Class.create({
 		this.cmdMenuModel = {
 				visible:true,
 				items: [
-					{label:$L('Reply'),     icon:'reply',     command:'reply'},
-					{label:$L('Reply all'), icon:'reply-all', command:'replyAll'},
-					{label:$L('Forward'),   icon:'forward-email', command:'forward'},
-					{label:$L('Delete'),    icon:'delete',    command:'delete'}
+					{label:$L('Reply'),     shortcut:'r',     command:'reply'},
+					{label:$L('Reply all'), shortcut:'e', command:'replyAll'},
+					{label:$L('Forward'),   shortcut:'f', command:'forward'},
+					{label:$L('Delete'),    shortcut:'d',    command:'delete'}
 				]};
 		this.controller.setupWidget(Mojo.Menu.commandMenu, undefined, this.cmdMenuModel);
 		
diff --git a/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js b/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js
index 57d3375..48629b2 100644
--- a/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js
+++ b/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js
@@ -190,6 +190,11 @@ var ChatviewAssistant = Class.create({
 				segmentCountContainer: this.controller.get('segmentCounterContainer'),
 				segmentCountElement: this.controller.get('segmentCounter'),
 				setTextFieldValueFn: this.setTextFieldValue.bind(this)
+			},
+			charCounter: {
+				charCountContainer: this.controller.get('charCounterContainer'),
+				charCountElement: this.controller.get('charCounter'),
+				setTextFieldValueFn: this.setTextFieldValue.bind(this)
 			}
 		};
 
diff --git a/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js.orig b/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js.orig
new file mode 100644
index 0000000..57d3375
--- /dev/null
+++ b/usr/palm/applications/com.palm.app.messaging/app/controllers/chatview-assistant.js.orig
@@ -0,0 +1,2652 @@
+/* Copyright 2009 Palm, Inc.  All rights reserved. */
+
+var ChatviewAssistant = Class.create({
+	initialize: function(chatThreadId,params){
+		Mojo.Log.info("++++++ChatviewAssistant::initialize");
+		Mojo.Log.info("ChatView %j", params)
+		this.appController = Mojo.Controller.getAppController();
+		this.Messaging = this.appController.Messaging;
+		this.chatData = {};
+		this.chatThreadId = chatThreadId;
+		this.focusWindow = false;
+		this.launchToAddress;
+		this.clearListBadgeFn;
+		if(params) {
+			if(params.focusWindow)
+				this.focusWindow = true;
+			if(params.contactPointId)
+				this.launchToContactPointId = params.contactPointId;
+			if(params.clearListBadgeFn)
+				this.clearListBadgeFn = params.clearListBadgeFn;
+			if (params.address)
+				this.launchToAddress = params.address;
+		}
+		this.initialLoadComplete = false;
+		this.listReset = false;
+		this.hasSetChatToReadAndSetDraftText = false;
+		this.isWindowFocused = true;
+		this.isScreenOn = true;
+		this.isScreenLocked = false;
+		this.isSceneActive = false;
+		this.bottomBeforeDeactivate = null;
+		this.fixScrollPositionOnActivate = false;
+		this.avatarHash = {}; // key = chatAddress, value = /path/to/avatar
+		this.contactAvatar;
+		this.chatDisplayName;
+		this.transports = [];
+		this.invitations = [];
+		this.selectedTransport = {};
+		this.IMAddressSubscriptions = [];
+		this.attachment;
+		this.messageTextElement;
+		this.hasLoadedChatList = false;
+		this.attemptedToFixChatWithBadPersonId = false;
+		this.chatListSubscriberId = null;
+		this.MAX_BOTTOM_HEIGHT_FOR_SNAP = 300;
+		this.chatHasTransientStatusMessage = false;
+		this.TRANSIENT_MESSAGES = {};
+		this.TRANSIENT_MESSAGES[this.Messaging.Availability.AVAILABLE] = {
+			template: new Template($L("#{chatAddress} is available")),
+			isTransientFn: ChatFlags.isTransientAvailable
+		};
+		this.TRANSIENT_MESSAGES[this.Messaging.Availability.BUSY] = {
+			template: new Template($L("#{chatAddress} is busy")),
+			isTransientFn: ChatFlags.isTransientBusy
+		};
+		this.TRANSIENT_MESSAGES[this.Messaging.Availability.OFFLINE] = {
+			template: new Template($L("#{chatAddress} is offline")),
+			isTransientFn: ChatFlags.isTransientOffline
+		};
+		this.messageTemplatePath = 'chatview/message/';
+		
+		this.appMenuAddPictureItem = {
+			label: $L('Add picture...'),
+			command: 'addPicture',
+			disabled: false
+		};
+
+		this.appMenuBlockUsernameItem = {
+			label: $L('Block this person'),
+			command: 'blockUsername'
+		};
+
+		this.appMenuAttrs = {
+			omitDefaultItems: true
+		};
+
+		// Add "Copy All" to the standard edit menu.
+		var chatEditItems = {
+			label: $L('Edit'),
+			items: [
+				Mojo.Menu.cutItem,
+				Mojo.Menu.copyItem,
+				{label: $L('Copy All'), command: 'copyall'},
+				Mojo.Menu.pasteItem
+			]
+		};
+
+		this.appMenuModel = {
+			visible: true,
+			label: $L('Chat view menu'),
+			items: [
+				chatEditItems,
+				this.appMenuAddPictureItem,
+				Mojo.Menu.helpItem
+			]
+		};
+		
+		this.newMessageFieldLoseFocus = function(event){
+			if (this.messageTextElement !== undefined) {
+				this.messageTextElement.focus();
+			}
+		}.bind(this);
+		
+		this.listLoadedTimerFn = this._debouncedListLoadedHelper.bind(this);
+		this.mmsImageOnLoad = this.mmsImageOnLoad.bind(this);
+		this.mmsImageOnError = this.mmsImageOnError.bind(this);
+		
+		this.handleWindowResize = this.handleWindowResize.bindAsEventListener(this);
+		this.handleMessageTap = this.handleMessageTap.bindAsEventListener(this);
+		this.handleMessageDelete = this.handleMessageDelete.bindAsEventListener(this);
+		this.renderTransportPickerPopup = this.renderTransportPickerPopup.bindAsEventListener(this);
+		this.considerForSend = this.considerForSend.bind(this);
+		this.attachFilePicker = this.attachFilePicker.bind(this);
+		this.handleCancelAttachment = this.resetTextBox.bind(this, false);
+		this.handleTextAreaChange = this.handleTextAreaChange.bind(this);
+		this.handleTextAreaKeyUp = this.handleTextAreaKeyUp.bind(this);
+		this.handleScreenStateChange = this.handleScreenStateChange.bind(this);
+		this.handleFocus = this.handleFocus.bind(this);
+		this.handleLoseFocus = this.handleLoseFocus.bind(this);
+
+		this.appController.notificationAssistant.clearNotificationsForChat(this.chatThreadId);
+	},
+	
+	setup: function(){	
+		Mojo.Log.info("++++++ChatviewAssistant::setup");
+		this.controller.setupWidget(Mojo.Menu.appMenu, this.appMenuAttrs, this.appMenuModel);
+		
+		var messageTextWidgetAttributes = {
+			modelProperty: 'value',
+			hintText: $L('Enter message here...'),
+			multiline: true,
+			focus: false,
+			enterSubmits: true,
+			textFieldName: "messageTextElement",
+			className: " ",
+			changeOnKeyPress: true
+		};
+		this.messageTextWidgetModel = {};
+		this.controller.setupWidget('messageTextWidget', messageTextWidgetAttributes, this.messageTextWidgetModel);	
+		
+		this.chatListAttr = {
+			itemTemplate: 'chatview/chatList-row',
+			listTemplate: 'chatview/chatList-container',
+			itemsCallback: this.chatListItemsCallback.bind(this),
+			dividerTemplate: 'chatview/separator',
+			dividerFunction: this.chatListDividerFunction.bind(this),
+			onItemRendered: this.itemRendered.bind(this),
+			swipeToDelete: true,
+			uniquenessProperty: 'messageId'
+		};
+		this.chatListModel = {}; // This is used to reset the list by calling modelChanged
+		this.controller.setupWidget('chatlist', this.chatListAttr, this.chatListModel);
+	},
+	
+	ready: function() {
+		Mojo.Log.info("++++++ChatviewAssistant::ready");
+		this.chatListWidget = this.controller.get('chatlist');
+		this.actionButton = this.controller.get('ActionButton');
+		this.sendButton = this.controller.get('SendButton');
+		this.attachButton = this.controller.get('AttachButton');
+		this.transportPicker = this.controller.get('msg-transport-picker');
+		this.currentTransportDownArrow = this.controller.get('currentTransportDownArrow');
+		this.cancelAttachment = this.controller.get('cancelAttachment');
+		this.chatViewHeaderClickTarget = this.controller.get('chatViewHeaderClickTarget');
+		this.chatViewRecipientName = this.controller.get('chatViewRecipientName');
+		
+		this.messageTextWidget = this.controller.get('messageTextWidget');
+		this.messageTextElement = this.messageTextWidget.querySelector('[name=messageTextElement]');
+		
+		//this.chatListWidget.observe("click", this.onClickHandler);
+		
+		this.chatListWidget.observe(Mojo.Event.listTap, this.handleMessageTap);
+		this.chatListWidget.observe(Mojo.Event.listDelete, this.handleMessageDelete);
+		this.sendButton.observe(Mojo.Event.tap, this.considerForSend);
+		this.attachButton.observe(Mojo.Event.tap, this.attachFilePicker);
+		
+		this.cancelAttachment.observe(Mojo.Event.tap, this.handleCancelAttachment);
+	
+		this.messageTextElement.observe('keyup', this.handleTextAreaKeyUp);
+		this.messageTextWidget.observe(Mojo.Event.propertyChange, this.handleTextAreaChange);
+
+		// observe keydown/keyup on the text field WIDGET to handle height changes due to text forcing it to resize
+		this.fixListScrollPositionOnLoad = this._fixListScrollPositionOnLoad.bind(this, this.messageTextWidget, this.chatListWidget);
+		this.handleTextFieldResize = this._fixListScrollPositionWhenTextFieldResize.bind(this, this.messageTextWidget, this.chatListWidget);
+		this.messageTextWidget.observe('keydown', this.handleTextFieldResize);
+		this.messageTextWidget.observe('keyup', this.handleTextFieldResize);
+		
+		var charCounterParams = {
+			segmentCounter: {
+				segmentCountContainer: this.controller.get('segmentCounterContainer'),
+				segmentCountElement: this.controller.get('segmentCounter'),
+				setTextFieldValueFn: this.setTextFieldValue.bind(this)
+			}
+		};
+
+		this.characterCounter = new CharacterCounter(this.controller,this.Messaging.messagingPrefs.platformType,this.messageTextElement,charCounterParams);
+		MessagingMojoService.getChatDetails(this.controller, this.chatThreadId, this.renderChatViewHeader.bind(this));
+		this.controller.window.addEventListener('resize', this.handleWindowResize, false);
+		
+		this.controller.document.addEventListener(Mojo.Event.stageActivate, this.handleFocus, false);
+		this.controller.document.addEventListener(Mojo.Event.stageDeactivate, this.handleLoseFocus, false);
+		
+		this.Messaging.DisplayState.observe(this.handleScreenStateChange);
+		MessagingMojoService.getLockStatus(this.controller, this.handleLockScreenStateChange.bind(this));
+	},
+	
+	handleScreenStateChange: function(isScreenOn) {
+		Mojo.Log.info("[CV] ***** handle screen state change:", isScreenOn);
+		this.isScreenOn = isScreenOn;
+		this.handleClearNotifications();
+	},
+	
+	handleLockScreenStateChange: function(result) {
+		Mojo.Log.info("[CV] ****** getLockStatus: %j",result);
+		if(result && result.locked) {
+			this.isScreenLocked = true;
+		} else {
+			this.isScreenLocked = false;
+		}
+		this.handleClearNotifications();
+	},
+	
+	handleClearNotifications: function() {
+		if(this.isWindowFocused && this.isSceneActive && this.isScreenOn && !this.isScreenLocked) {
+			Mojo.Log.info("[CV] ****** handleClearNotifications ---- calling handleFocus()");
+			this.handleFocus();
+		}		
+	},
+
+	cleanup: function(){
+		this.chatViewHeaderClickTarget.stopObserving(Mojo.Event.tap, this.handleHeaderTap);
+		this.chatListWidget.stopObserving(Mojo.Event.listTap, this.handleMessageTap);
+		this.sendButton.stopObserving(Mojo.Event.tap, this.considerForSend);
+		this.attachButton.stopObserving(Mojo.Event.tap, this.attachFilePicker);
+		this.transportPicker.stopObserving(Mojo.Event.tap, this.renderTransportPickerPopup);
+		this.cancelAttachment.stopObserving(Mojo.Event.tap, this.handleCancelAttachment);
+		this.messageTextWidget.stopObserving('keydown', this.handleTextFieldResize);
+		this.messageTextWidget.stopObserving('keyup', this.handleTextFieldResize);
+		this.messageTextWidget.stopObserving(Mojo.Event.propertyChange, this.handleTextAreaChange);
+		this.messageTextElement.stopObserving('keyup', this.handleTextAreaKeyUp);
+		this.Messaging.DisplayState.stopObserving(this.handleScreenStateChange);
+		this.controller.document.removeEventListener(Mojo.Event.stageActivate, this.handleFocus, false);
+		this.controller.document.removeEventListener(Mojo.Event.stageDeactivate, this.handleLoseFocus, false);
+		this.controller.window.removeEventListener('resize', this.handleWindowResize, false);
+		this.characterCounter.destroy();
+		if(!this.hasSetChatToReadAndSetDraftText) {
+			this.setChatToReadAndSetDraftText();
+		}
+		
+		if(this.clearListBadgeFn) {
+			this.clearListBadgeFn();
+		}		
+	},
+	
+	setChatToReadAndSetDraftText: function() {
+		this.hasSetChatToReadAndSetDraftText = true;
+		MessagingMojoService.setChatToReadAndSetDraftText(this.controller, this.chatThreadId, this.messageTextElement.value, this.chatHasTransientStatusMessage);
+	},
+	
+	aboutToActivate: function(afterAboutToActivateFn) {
+		this.afterAboutToActivateFn = afterAboutToActivateFn;
+		// We need to revealBottom() when a scene is popped off from on top of us and we received a 
+		// new message while the chat was hidden
+		// this.fixScrollPositionOnActivate will be false when the scene initially loads
+		if(this.fixScrollPositionOnActivate && this.bottomBeforeDeactivate < this.MAX_BOTTOM_HEIGHT_FOR_SNAP) {
+			this.revealBottomHack();
+			this.fixScrollPositionOnActivate = false;
+		}
+		
+		if(this.hasInitialBottomWindow && this.afterAboutToActivateFn) {
+			this.afterAboutToActivateFn();
+		}
+		
+	},
+	
+	activate: function(){
+		this.isSceneActive = true;
+		this.bottomBeforeDeactivate = null;
+		// clear any dashboard notifications for this chat if they exist
+		this.messageTextElement.observe('blur', this.newMessageFieldLoseFocus);
+		this.newMessageFieldLoseFocus();
+		if(this.focusWindow) {
+			this.focusWindow = false;
+			this.controller.stageController.activate();
+		}
+		this.handleClearNotifications();
+	},
+	
+	deactivate: function(){
+		this.isSceneActive = false;
+		this.bottomBeforeDeactivate = this.getCurrentBottom();
+		this.messageTextElement.stopObserving('blur', this.newMessageFieldLoseFocus);
+	},
+	
+	handleWindowResize: function(event) {
+		if(!this.isSceneActive) {
+			this.fixScrollPositionOnActivate = true;
+		} else if (this.getCurrentBottom() < this.MAX_BOTTOM_HEIGHT_FOR_SNAP) {
+			this.revealBottomHack();
+		}		
+	},	
+	
+	handleFocus: function() {
+		this.isWindowFocused = true;
+		this.appController.notificationAssistant.clearNotificationsForChat(this.chatThreadId);
+	},
+	
+	handleLoseFocus: function() {
+		this.isWindowFocused = false;
+	},
+	
+	handleCommand: function(event){
+		if (event.type == Mojo.Event.command) {
+			if (event.command == 'addPicture') {
+				this.attachFilePicker();
+				event.stop();
+			} else if (event.command == 'blockUsername') {
+				this.blockUsername();
+				event.stop();
+			} else if (event.command == 'copyall') {
+				this.copyConversationToClipboard();
+			}
+		} else if(event.type == Mojo.Event.back) {
+			event.stop();
+			this.popAndRevealListView();
+		 	return;
+		 }
+	},
+	
+	popAndRevealListView: function() {
+		// on scene unload, mark all new messages in this chat as read
+		if(!MessagingUtils.sceneExistsInStack(this.controller.stageController,'listview')) {
+			this.setChatToReadAndSetDraftText();
+			this.appController.assistant.getListChunk(this.controller,this.handleListChunkOnPop.bind(this));
+		} else {
+			this.controller.stageController.popScenesTo('listview');
+		}		
+	},
+	
+	handleListChunkOnPop: function(forceListView,result) {
+		this.controller.stageController.popScenesTo('listview');
+		this.controller.stageController.pushScene('listview',{forceListView:forceListView, listDataChunk:result});
+	},
+	
+	considerForNotification: function(data){
+		Mojo.Log.info("[CV] ****** chatview considerForNotification");
+		// always put the notification through if the screen is off
+		// if we are in the chat and the screen is on, do not display a banner + dashboard, just play a notification sound 
+		if(this.isScreenOn && data.chatThreadId == this.chatThreadId) {
+			Mojo.Log.info("[CV] ****** chatview considerForNotification --- screen is on!");
+			if(data.notificationType == this.Messaging.notificationTypes.newMessage) {
+				data = {playSoundOnly:true};
+			} else if( data.notificationType == this.Messaging.notificationTypes.sendFailure) {
+				data = {}; // wipe out the notification because we are in the chat
+			}
+		}
+		return data;
+	},
+	
+	/**
+	 * This is called when the app is open, the chatview is the top card in the stack, and
+	 * another app is attempting to launch messaging to a specific chat
+	 * @param {Object} chatThreadId
+	 * @param {Object} contactPointId
+	 */
+	considerForChatLaunch: function(chatThreadId,contactPointId, address, serviceName) {
+		if(chatThreadId == this.chatThreadId) {
+			// The chat is already open but could be set to a different transport
+			// Re-render the transport picker if a contactPointId is specified
+			if(contactPointId)
+				this.renderTransportPicker({contactPointId:contactPointId,address:address,serviceName:serviceName});
+			return false;
+		} else {
+			return true;
+		}			
+	},
+	
+	// TODO: Cleanup this method and separate some of the logic
+	renderChatViewHeader: function(response){
+		// If the event == deleted, then pop out of the chat
+		if(response.event && response.event == "deleted") {
+			this.popAndRevealListView();
+		}
+		
+		// keep a reference to the chat data.  We need the flags for the transient status message logic
+		this.chatData = response.record;
+		
+		// set the contactAvatar - this is used for SMS/MMS messages
+		this.contactAvatar = response.record.pictureLocation || response.record.imAvatarLocation || null;
+		
+		response.record.displayName = MessagingUtils.getContactDisplayName(response.record).strip();
+		if(!response.record.serviceName && response.record.displayName) {
+			response.record.displayName = MessagingUtils.formatPhoneNumber(response.record.displayName);
+		}
+		if(!this.chatDisplayName || this.chatDisplayName != response.record.displayName) {
+			this.chatViewRecipientName.update(response.record.displayName);
+			this.chatDisplayName = response.record.displayName;
+		}		
+		
+		// keep track of the unread count so we can determine if the reason that the chat header
+		// data changed is because of a new message.  This is the only case where we should change
+		// the currently selected transport
+		var lastUnreadCount;
+		if(this.lastUnreadCount == undefined)
+			lastUnreadCount = response.record.unreadCount;
+		else
+			lastUnreadCount = this.lastUnreadCount;
+		this.lastUnreadCount = response.record.unreadCount;
+		
+		if (this.pickerIsBuilt) {			
+			// if the picker is built and the chat address changes because of a new incoming message, set the selected 
+			// transport to the incoming account. This happens when you are on a different transport than an incoming message
+			if (lastUnreadCount != response.record.unreadCount && this.selectedTransport.chatAddress && this.selectedTransport.chatAddress != response.record.chatAddress) {
+				this.findAndSetSelectedTransport(this.transports, response.record.serviceName, response.record.chatAddress, response.record.availability);
+			}
+			return; // do not re-render the picker if it is already built!
+		}
+		this.pickerIsBuilt = true;
+		
+		// if there are transient chat flags set, then we failed to clear them when the chat was last popped
+		// indicate that we have transient messages in the chat so we can clear them on pop
+		if(ChatFlags.isTransient(response.record.flags)) {
+			this.chatHasTransientStatusMessage = true;
+		}
+		
+		if(response.record.draftText) {
+			this.setTextFieldValue(response.record.draftText);
+		}
+		
+		// If this async request comes back after the list had loaded, fix the scroll position because
+		// we may have just changed the hieght of the text box by setting the draft text
+		if(this.initialLoadComplete) {
+			this.fixListScrollPositionOnLoad();
+		} else {
+			this.fixListScrollPositionOnLoad(true);
+		}
+		
+		if (response.record.name.substring(0, 3) === 'pID') {
+			this.personId = response.record.name.substring(3);
+			var transportPickerParams = {
+				serviceName: response.record.serviceName,
+				chatAddress: response.record.chatAddress,
+				availability: response.record.availability,
+				contactPointId: this.launchToContactPointId,
+				address: this.launchToAddress
+			};
+			this.renderTransportPicker(transportPickerParams);
+		} else {
+			this.transports.push({serviceName: null, value: response.record.chatAddress});
+			this.setSelectedTransport(null, response.record.chatAddress, response.record.serviceName, null, null);
+			this.initChatList();
+		}
+		
+		this.handleHeaderTap = this.handleHeaderTap.bind(this, response.record.serviceName, response.record.chatAddress);
+		this.chatViewHeaderClickTarget.observe(Mojo.Event.tap, this.handleHeaderTap);
+		
+		// The chat details will tell us if this chat has any invitations
+		if (ChatFlags.isInvitation(response.record.flags)) {
+			// Retrieve all invitations for this chat - typically this will be just one
+			// FIXME: should we subscribe to this?  Currently if a new invitation comes in
+			//        while the chatview is open, the user will have to back out to the listview
+			//        and come back into the chat or click on the invitation in the listview
+			MessagingMojoService.getInvitationsFromChat(this.controller, this.chatThreadId, function(result){
+				this.invitations = result.list;
+				this.renderInvitationUI();
+			}.bind(this));
+		}
+
+		this.updateBlockUsernameMenu();
+	},
+	
+	handleHeaderTap: function(serviceName, chatAddress, event) {
+		// If this chat is not associated with a contact, launch contacts with add UI
+		if (!this.personId) {
+			this.pushContactDetails(serviceName, chatAddress, null);
+		} else {	// we have a personId
+			// If we were unable to retrieve any transports for this chat, 
+			// make sure that the personId still exists.  Sometimes we will have a bogus
+			// personId when contacts get clipped and a person is deleted. The messaging
+			// data model stores the person ids
+			if(!this.transports.length) {
+				MessagingMojoService.reverseLookup(
+											this.controller, 
+											chatAddress, 
+											this.handleContactsReverseLookup.bind(this, serviceName, chatAddress), 
+											this.handleContactsReverseLookup.bind(this, serviceName, chatAddress));
+			} else {
+				this.pushContactDetails(null, null, this.personId);
+			}
+		}
+	},
+	
+	handleContactsReverseLookup: function(serviceName, chatAddress, result) {
+		if(result.record && result.record.id) {
+			this.pushContactDetails(null, null, result.record.id);
+		} else {
+			this.pushContactDetails(serviceName, chatAddress, null);
+		}
+	},
+	
+	pushContactDetails: function(serviceName, chatAddress, personId) {
+		var contactsAppArgs = {
+			appId : 'com.palm.app.contacts',
+			name: 'detail'
+		};
+		var params = {};
+		if(personId) {
+			params = {personId:personId};
+		} else if(!serviceName && chatAddress && chatAddress.indexOf("@") > -1) {
+			params = {
+				contact: {
+					emailAddresses:[{value:chatAddress}]
+				}
+			};	
+		} else if(serviceName && chatAddress) {
+			params = {
+				contact: {
+					imNames:[{value:chatAddress, serviceName:serviceName}]
+				}
+			};
+		} else {
+			params = {
+				contact: {
+					phoneNumbers:[{value:chatAddress}]
+				}
+			};
+		}
+		Pseudocard.pushPseudocard(this.controller.stageController, params);
+	},	
+	
+	// The only time that the transport picker will be re-rendered is when a new invitation is accepted
+	renderTransportPicker: function(params){
+		if(!params)
+			params = {};
+		MessagingMojoService.getTransportTypes(this.controller, this.personId, this.retrieveTransportData.bind(this, params));
+		this.transportPicker.stopObserving();
+		this.transportPicker.observe(Mojo.Event.tap, this.renderTransportPickerPopup);
+	},
+	
+	/*
+	 * This goes through all the contact points to render the transport picker
+	 * Contact points are the recipients gmail accounts, aol accounts, sms number, etc
+	 */
+	retrieveTransportData: function(transportParams, data){
+		var fixSuspiciousChat = false;
+		var params = Object.extend({serviceName:'',chatAddress:'',contactPointId:'', address:''},transportParams);
+		
+		var transportsPhone = [];
+		var transportsIM = [];
+		
+		// build a temporary hash of IM types that we support
+		var myAccountTypes = this.Messaging.IMAccounts.getMyAccountTypesHash();
+		
+		// preformat data + subscribe to updates for all IM addresses + setup avatarHash
+		for(var i=0; i<data.list.length; i++) {
+			var transport = data.list[i];
+			if (!transport.displayName) 
+				transport.displayName = transport.value;
+			if(transport.serviceName)
+				transport.serviceName = transport.serviceName.toLowerCase();
+			
+			transport.availabilityClass = this.Messaging.Availability.getPopupAvailabilityClass(transport.availability);
+			transport.transportIcon = this.Messaging.transports.getTransportByName(transport.serviceName).largeIcon;
+			transport.transportIconClass = this.Messaging.transports.getTransportByName(transport.serviceName).className;
+			// Found an IM address
+			if (transport.type == "IM" || transport.serviceName) {
+				if(transport.serviceName) {
+					this.avatarHash[transport.value] = transport.avatarLocation;
+					// only add the transport if we have an account of that type
+					if(myAccountTypes[transport.serviceName]) {
+						transport.displayName = transport.value;
+						transportsIM.push(transport);
+					}
+				}
+			} else {
+				transport.value = MessagingUtils.cleanPhoneNumber(transport.value);
+				transport.displayName = MessagingUtils.formatPhoneNumber(transport.value);
+				transportsPhone.push(transport);
+			}
+			
+		}
+		this.transports = transportsPhone.concat(transportsIM); // make sure phone numbers come first for the transport picker
+		this.findAndSetSelectedTransport(this.transports, params.serviceName, params.chatAddress, params.availability, params.contactPointId, params.address);
+		
+		// we are in this method because we have a personId.
+		// if we do not have any results from calling listContactPoints then something is wrong
+		// hit the service to do a reverse lookup and fix the chat data
+		if(!data.list.length && !this.attemptedToFixChatWithBadPersonId) {
+			this.attemptedToFixChatWithBadPersonId = true; // this is also referenced when we observe the transports in the list callback
+			fixSuspiciousChat = true;
+		}		
+		
+		// load the chatlist if we have not already done this
+		this.initChatList();
+
+		if(fixSuspiciousChat) {
+			MessagingMojoService.fixChatWithBadPersonId(this.controller, this.chatThreadId, this.personId, params.serviceName, params.chatAddress, this.handleFixChatWithBadPersonId.bind(this, transportParams));
+		}
+	},
+	
+	handleFixChatWithBadPersonId: function(transportParams, result) {
+		// There will be a newPersonId if the reverse lookup was successful and we updated the chat details
+		// If there is no newPersonId then that means the chat has no transports.  The chat is clearly messed up, 
+		// so we will not be observing any IMAddress changes.  We should never get into this state.
+		if(result.newPersonId) {
+			this.personId = result.newPersonId;
+			// re-render the transport picker for the new personId
+			this.renderTransportPicker(transportParams);
+		}
+	},
+	
+	observeTransportIMAddresses: function(transports) {
+		// cancel any subscriptions to IM Addresses -- we will already
+		// have subscriptions if the transport picker has already been rendered
+		for(var i=0; i<this.IMAddressSubscriptions.length; i++) {
+			this.controller.cancelServiceRequest(this.IMAddressSubscriptions[i]);
+		}
+		this.IMAddressSubscriptions.clear();		
+		
+		// Observe IM addresses that have legit presence values.  IM addresses that are not
+		// on your buddy list will have NO_PRESENCE
+		for(var i=0; i<transports.length; i++) {
+			var transport = transports[i];
+			if(transport.serviceName && transport.availability != this.Messaging.Availability.NO_PRESENCE) {
+				this.IMAddressSubscriptions.push(MessagingMojoService.observeIMAddress(this.controller, transport.value, transport.serviceName, this.handleIMAddressChange.bind(this)));
+			}
+		}
+	},
+	
+	handleIMAddressChange: function(data){
+		// Update the presence for the address
+		for(var i=0; i<this.transports.length; i++) {
+			var transport = this.transports[i];
+			if(!data.record.serviceName && data.record.value) {
+				data.record.value = MessagingUtils.cleanPhoneNumber(data.record.value);
+			}
+			if (transport.value == data.record.value && transport.serviceName == data.record.serviceName) {
+				var previousAvailability = this.selectedTransport.availability;
+				// current transport just went from online to offline
+				if (this.selectedTransport.contactPointId == transport.id) {
+					// FIXME: should this update more than just availability?
+					this.selectedTransport.availability = data.record.availability;
+					this.setCurrentTransportAvailabilityIcon(this.selectedTransport.availability);
+				}
+				transport.availability = data.record.availability;
+				// add chat bubbles to the list for the user going offline/online
+				if (this.selectedTransport.contactPointId == transport.id && transport.serviceName && this.TRANSIENT_MESSAGES[transport.availability]) {
+					// availability has changed & we have not already inserted a transient message for the new availability + address
+					var transientMessageExists = this.TRANSIENT_MESSAGES[transport.availability].isTransientFn(this.chatData.flags);
+					if(previousAvailability != transport.availability && 
+						(!transientMessageExists ||	(transientMessageExists && transport.chatAddress != this.chatData.statusAddress))) {
+
+						var message = this.TRANSIENT_MESSAGES[transport.availability].template.evaluate({chatAddress:transport.value});
+						// special case for offline. Make sure we did not get logged out
+						if(transport.availability == this.Messaging.Availability.OFFLINE) {
+							var account = this.Messaging.IMAccounts.getAccountFromAccountTagOrServiceName(data.record.accountTag, data.record.serviceName);
+							if(account && account.availability == this.Messaging.Availability.OFFLINE) {
+								message = $L("You are offline");
+							}
+						}
+
+						this.addStatusMessageToChat(message,transport.availability);
+					}
+
+					// Whenever the buddy's custom message changes, show it in the chat list. 
+					// NOTE: if this ever needs to persist, maybe move it to BaseIMTransport.updateChatPresence
+					if (data.record.customMessage && this.chatData.customMessage != data.record.customMessage) {
+						this.chatData.customMessage = data.record.customMessage;
+						this.addStatusMessageToChat(this.chatData.customMessage,this.Messaging.Availability.AVAILABLE);
+					}
+				}
+			}
+		}
+		
+		// determine if the avatar hash has changed
+		if (this.avatarHash[data.record.value] && this.avatarHash[data.record.value] != data.record.avatarLocation) {
+			//Mojo.Log.info("*** Calling invalidateItems because the avatar hash has changed!");
+			// update the avatarHash
+			this.avatarHash[data.record.value] = data.record.avatarLocation;
+			this.chatListWidget.mojo.invalidateItems(0); // invalidate the list items so it will reload the window
+		}
+	},
+	
+	renderTransportPickerPopup: function(e){
+		// don't render the transport picker popup if there is only one transport
+		if(this.transports.length <= 1)
+			return;
+		
+		var listItems = [];
+		var foundPhone = false;
+		listItems.push({
+			label: $L("Send message to..."),
+			command: ' ',	// Do NOT Localize
+			disabled: true
+		});
+		
+		for(var i=0; i<this.transports.length; i++) {
+			var transport = this.transports[i];
+			// only render one divider for multiple phone numbers.  All IM accounts
+			// get a divider.
+			if ((!foundPhone && !transport.serviceName) || transport.serviceName) {
+				foundPhone = true;
+				listItems.push({
+					label: this.Messaging.transports.getTransportByName(transport.serviceName).displayName.toUpperCase()
+				});
+			}
+			
+			// TODO: When we have multiple accounts of the same type, append the account username
+			var rowParams = {
+				label: transport.displayName,
+				command: "transport" + transport.id // concat a string with the contactPointId just incase the id was ever null
+													// to avoid having this transport be rendered as a divider by mistake
+			};
+			if(transport.availability != undefined) {
+				rowParams.secondaryIcon = this.Messaging.Availability.getPopupAvailabilityClass(transport.availability);
+			}
+			
+			listItems.push(rowParams);
+		}
+		
+		this.controller.popupSubmenu({
+			onChoose: this.handleTransportSelection.bind(this),
+			toggleCmd: "transport" + this.selectedTransport.contactPointId, // set this to the current transport
+			placeNear: e.target,
+			//manualPlacement:true,
+			items: listItems
+		});
+	},
+	
+	handleTransportSelection: function(selectedValue){
+		if(!selectedValue)
+			return;
+
+		// iterate through transports and find the selected one
+		var that = this;
+		this.transports.each(function(transport){
+			if ("transport" + transport.id == selectedValue) {
+				that.setSelectedTransport(transport.id, transport.value, transport.serviceName, transport.accountTag, transport.availability);
+				throw $break;
+			}
+		});
+		this.messageTextElement.focus();
+	},
+	
+	setSelectedTransportFromId: function(transportId){
+		var that = this;
+		this.transports.each(function(transport){
+			if (transport.id == transportId) {
+				that.setSelectedTransport(transport.id, transport.value, transport.serviceName, transport.accountTag, transport.availability);
+				throw $break;
+			}
+		});
+	},
+	
+	// TODO: this could be further improved to choose an online transport over one that is offline
+	//       when no exact matches are found
+	findAndSetSelectedTransport: function(data, serviceName, chatAddress, availability, contactPointId, address){
+		var selectedTransport;
+		if(data.length > 0) {
+			if(contactPointId) {  // simple search if we have the contact point id
+				var found = false;
+				for(var i=0; i<data.length; i++) {
+					var transport = data[i];
+					if(transport.id == contactPointId){
+						selectedTransport = transport;
+						found = true;
+					}
+				}
+				
+				if ((!found) && (address)){
+					Mojo.Log.info("contactId not found, rerun looking for matching phone number address " + address);
+					for(var i=0; i<data.length; i++) {
+						var transport = data[i];
+						Mojo.Log.info("value " + transport.value);
+						if(transport.value == address){
+							Mojo.Log.info("found here");
+							selectedTransport = transport;
+						}
+					}
+				}
+			} else {
+				serviceName = Object.isString(serviceName) ? serviceName.toLowerCase() : "";
+				chatAddress = Object.isString(chatAddress) ? chatAddress.toLowerCase() : "";
+				// selected transport is a phone number
+				if (!serviceName) {
+					// grab only phone numbers
+					var numbers = [];
+					data.each(function(transport){
+						if (!transport.serviceName) 
+							numbers.push(transport);
+					});
+					var bestMatches = MessagingUtils.findBestPhoneNumberMatches(chatAddress, numbers, 'value');
+					if (bestMatches.length > 0) 
+						selectedTransport = bestMatches[0];
+				} else { // transport is IM
+					data.each(function(transport){
+						var transportServiceName = transport.serviceName ? transport.serviceName.toLowerCase() : "";
+						var transportChatAddress = transport.value ? transport.value.toLowerCase() : "";
+						if (transportServiceName == serviceName && transportChatAddress == chatAddress)
+							selectedTransport = transport;
+					});
+				}
+			}
+			
+			// if there was no match, use a transport of the same type
+			// else: just use the first transport as a last resort
+			if(!selectedTransport && data.length > 0) {
+				var foundMatch = false;
+				var backupChoice;
+				for(var i=0; i<data.length && !foundMatch; i++) {
+					var transport = data[i];
+					// match if both are phone numbers (serviceName == null) or match where the serviceNames are the same (same IM transport)
+					if((!serviceName && !transport.serviceName) || (serviceName && transport.serviceName && serviceName == transport.serviceName)) {
+						selectedTransport = transport;
+						foundMatch = true;
+					}
+					// backup match: both are an IM transport.  We will use this if we cannot match another IM transport with the same serviceName
+					if(serviceName && transport.serviceName)
+						backupChoice = transport;
+				}
+	
+				if(!selectedTransport) {
+					if(backupChoice) {
+						selectedTransport = backupChoice;	// use the backup if we have one
+					} else {
+						selectedTransport = data[0];		// only other option is to use the first transport in the array
+					}
+						
+					
+				}
+				Mojo.Log.warn('Unable to match transport that the chat was launched with, choosing the best one.');
+			}
+		} else {
+			// This chat is clearly messed up because we didn't find any transports use the chat address from the chat data
+			selectedTransport = {
+				id: 0, // we did not match a transport, so we don't have an id
+				value: chatAddress,
+				serviceName: serviceName,
+				availability: this.Messaging.Availability.NO_PRESENCE, // set the availability to no presence because this will never update if we set it to the availability on the chat
+				accountTag: null 
+			};
+		}
+		this.setSelectedTransport(selectedTransport.id, selectedTransport.value, selectedTransport.serviceName, selectedTransport.accountTag, selectedTransport.availability);
+	},
+	
+	// This is a simple setter.  No data validation will happen here.
+	setSelectedTransport: function(id, value, serviceName, accountTag, availability){
+		this.selectedTransport.contactPointId = id;
+		this.selectedTransport.chatAddress = value;
+		this.selectedTransport.serviceName = serviceName;
+		this.selectedTransport.accountTag = accountTag;		
+		this.selectedTransport.availability = availability;
+		this.setCurrentTransportAvailabilityIcon(availability);
+		this.controller.get('currentTransport').update(this.Messaging.transports.getTransportByName(serviceName).secondaryDisplayName);
+		
+		if(!this.hasTransportBeenSet) {
+			this.hasTransportBeenSet = true;
+			
+			this.launchToContactPointId = null; // this is only used at launch to initially set the selected transport
+		
+			// Put a transient message into the chat If the current transport is IM & it is different than the aggregate chat availability
+			if(serviceName && availability && this.TRANSIENT_MESSAGES[availability] && (this.chatData.availability != availability)) {
+				var message = this.TRANSIENT_MESSAGES[availability].template.evaluate({chatAddress:value});
+				// special case for offline. Make sure we did not get logged out
+				if(availability == this.Messaging.Availability.OFFLINE) {
+					var account = this.Messaging.IMAccounts.getAccountFromAccountTagOrServiceName(accountTag, serviceName);
+					if(account && account.availability == this.Messaging.Availability.OFFLINE) {
+						message = $L("You are offline");
+					}
+				}				
+				this.addStatusMessageToChat(message,availability);
+			}			
+		}		
+		
+		if (!this.selectedTransport.serviceName) { // undefined means we are using the phone
+			// show the attach paper clip
+			this.showAttachButton();
+		} else {
+			this.hideAttachButton();
+			// if the attachment state is enabled, disable it
+			if (this.attachment) 
+				this.resetTextBox(false);
+		}
+		this.setCharacterCounterMaxLength();
+	},
+	
+	setCurrentTransportAvailabilityIcon: function(availability) {
+		var classStr = "";
+		if(availability != undefined)
+			classStr = this.Messaging.Availability.getNormalAvailabilityClass(availability);
+	 	else
+			classStr = this.Messaging.Availability.getNormalAvailabilityClass(this.Messaging.Availability.NO_PRESENCE);
+			
+		this.controller.get('presenceicon').className = 'chatview-header-status status-' + classStr;
+	},
+	
+	setCharacterCounterMaxLength: function() {
+		// set the max size for the textbox based on the transport
+		var params = {
+			maxPartLength: 1000,
+			maxParts: 1,
+			headerSize: 0,
+			encodings:""
+		};
+		
+		if(!this.attachment && !this.selectedTransport.serviceName) {
+			if(this.selectedTransport.chatAddress.indexOf("@") > -1) { // SMS to email
+				params.maxPartLength = (this.Messaging.carrierSettings.smsMessageSizeLimit - (this.selectedTransport.chatAddress.length + 1));
+				params.maxParts = 1;
+				params.headerSize = 0;
+			} else { // SMS
+				params.maxPartLength = this.Messaging.carrierSettings.smsMessageSizeLimit;
+				params.maxParts = this.Messaging.carrierSettings.smsMaxPartsPerMessage;
+				params.headerSize = this.Messaging.carrierSettings.smsHeaderSizeLimit;
+			}
+			
+			params.encodings = this.Messaging.carrierSettings.smsEncoding;
+		}	
+		
+		this.characterCounter.setSizeParams(params);		
+	},
+	
+	/***************************
+	 * CHATVIEW LIST
+	 ***************************/
+	initChatList: function(){
+		if(!this.hasInitChatList) {
+			this.hasInitChatList = true;
+			// only do this once when the chat is initially loaded
+			MessagingMojoService.getChatCount(this.controller, this.chatThreadId, this.handleSetInitialListLength.bind(this,this.chatListWidget), this.listReset);	
+		} else {
+			// something is changed (most likely the transport picker is being re-rendered)
+			// trash our subscriptions to observe the IM addresses & create them again
+			this.observeTransportIMAddresses(this.transports);
+		}
+		this.transportPicker.show();
+		if(this.transports.length <= 1)
+			this.currentTransportDownArrow.hide();	
+		else	
+			this.currentTransportDownArrow.show();
+	},
+	
+	handleSetInitialListLength: function(listWidget,data) {	
+		this.hasLoadedChatList = true;
+		listWidget.mojo.setLength(data.count);
+		this.revealBottomHack();
+		this.listInitialized = true;
+		if(data.count == 0)
+			this.controller.modelChanged(this.chatListModel);
+		else
+			listWidget.mojo.invalidateItems(0);			
+	},	
+	
+	chatListDividerFunction: function(item) {
+		if (!item) {
+			return;
+		}
+		// return a unique string for the divider
+		return item.dividerText;
+	},	
+	
+	chatListItemsCallback: function(listWidget, offset, limit){
+		Mojo.Log.info("+++++chatListItemsCallback");
+		if (this.listInitialized) {
+			//var range = this.chatListWidget.mojo.getLoadedItemRange();
+			//console.log("***@@@ Current window: " + range.offset + ", " + range.limit + "   Requesting offset: " + offset + ", limit:" + limit);
+			MessagingMojoService.getChatNew(this.controller, this.chatThreadId, this.updateChatList.bind(this, listWidget), this.listReset, this.chatListSubscriberId, listWidget.mojo.maxLoadedItems(), offset, limit);
+			this.listReset = false;
+		}
+	},
+	
+	updateChatList: function(listWidget, stuff){
+		if (stuff.subscriberId) 
+			this.chatListSubscriberId = stuff.subscriberId;
+		
+		// we have an update event
+		if (stuff.updated) {
+			this.handleChatListUpdateEvent(listWidget,stuff);
+			return;
+		}
+		this.preFormatChatList(listWidget, stuff);
+		
+		var offset = 0;
+		if (stuff.offset) 
+			offset = stuff.offset;
+			
+		// analyze the current bottom value before we change the list
+		var doRevealBottom = false;
+		
+		// if the scene is deactivated because another scene is on top, set fixScrollPositionOnActivate
+		// to indicate that we should check if we need to reveal bottom in aboutToActivate() 
+		if(!this.isSceneActive) {
+			this.fixScrollPositionOnActivate = true;
+		} else if (this.getCurrentBottom() < this.MAX_BOTTOM_HEIGHT_FOR_SNAP) {
+			doRevealBottom = true;
+		}
+
+		listWidget.mojo.noticeUpdatedItems(offset, stuff.list);		
+		
+		if (!this.hasInitialBottomWindow || doRevealBottom) {
+			if(!this.hasInitialBottomWindow && !this.attemptedToFixChatWithBadPersonId) {
+				// observe transport IM addresses after we have loaded the list
+				// delay this .5 seconds just in case the list is still fixing itself up
+				this.observeTransportIMAddresses.bind(this).delay(0.5,this.transports);
+			}
+			this.hasInitialBottomWindow = true;
+			this.revealBottomHack();
+		}
+		
+		if(this.afterAboutToActivateFn) {
+			this.afterAboutToActivateFn();
+			this.afterAboutToActivateFn = null;
+		}		
+		
+		if (stuff.list) {
+			// iterate over the attachments starting from the end of the list
+			// this will load the bottom image and lock our position there while
+			// all of the MMS content above loads
+			for(var i = stuff.list.length-1; i>=0; i--) {
+				var msg = stuff.list[i];
+				if (ChatFlags.hasAttachment(msg.flags)) {
+					MessagingMojoService.getMMSParts(this.controller, msg.messageId, this.buildMMSParts.bind(this, msg.messageId, msg.flags, (offset + i)));
+				}
+			}
+		}
+	},
+	
+	handleChatListUpdateEvent: function(listWidget,update) {
+		Mojo.Log.info("+++++handleChatListUpdateEvent ");
+		// ID updates do not require issuing a count query
+		// look up the item in the list and invalidate it
+		if(update.descriptions && update.descriptions.idUpdate) {
+			var loadedItemRange = listWidget.mojo.getLoadedItemRange();
+			var listItems = listWidget.mojo.getItems(loadedItemRange.offset,loadedItemRange.limit);
+			var foundMatch = false;
+			for(var i=0; i<listItems.length && !foundMatch; i++) {
+				if(listItems[i].messageId == update.descriptions.idUpdate) {
+					listWidget.mojo.invalidateItems(loadedItemRange.offset+i,1);
+					foundMatch = true;
+				}
+			}
+		} else {
+			MessagingMojoService.getChatCount(this.controller, this.chatThreadId, this.handleChatListUpdateEventAfterCountQuery.bind(this, listWidget, update), this.listReset);	
+		}
+	},
+	
+	handleChatListUpdateEventAfterCountQuery: function(listWidget, update, data) {
+		var newDataSize = data.count;
+		if(update.descriptions && (update.descriptions.outgoingMsg || update.descriptions.incomingMsg)) {
+			var insertLimit = listWidget.mojo.getLength();
+			// If the size hasn't changed, invalidate the widget since it isn't clear what to add or remove
+			if (newDataSize == insertLimit) {
+				listWidget.mojo.invalidateItems(0);
+			} else {
+				var sizeDelta = newDataSize - insertLimit;
+				// get the new data ourselves instead of setting the list length
+				// calling noticeUpdatedItems() in our subscribed callback will set the length properly
+				MessagingMojoService.getChatNew(this.controller, this.chatThreadId, null, this.listReset, this.chatListSubscriberId, listWidget.mojo.maxLoadedItems(), insertLimit, sizeDelta);
+			}
+
+		} else if(update.descriptions && update.descriptions.msgDeleted) {
+			// do nothing.  The list will remove the item so we can just ignore this event
+			// We already reset the list when we sent the delete request to the service
+		} else {
+			// update the count and reload the window
+			var currentListSize = listWidget.mojo.getLength();
+			
+			// This should only happen during weird events like chats getting merged
+			// This will not look pretty but it should rarely happen
+			if(newDataSize != currentListSize) {
+				// setLength will change the bottom position.  We need to analyze
+				// the position before we setLength, and keep it snapped to the bottom
+				var doRevealBottom = false;
+				if (this.getCurrentBottom() < this.MAX_BOTTOM_HEIGHT_FOR_SNAP)
+					doRevealBottom = true;
+							
+				listWidget.mojo.setLength(newDataSize);
+				
+				if(doRevealBottom) {
+					this.revealBottomHack();
+				}
+			} else {
+				listWidget.mojo.invalidateItems(0);
+			}
+		}		
+	},
+
+	/**
+	 * We need to instantiate audio objects after they have been rendered
+	 * This method is called every time a new item is added to the DOM
+	 * We keep a cache of audio objects so that we don't lose the
+	 * play state of the audio object.
+	 * 
+	 * @param {Object} listWidget
+	 * @param {Object} itemModel
+	 * @param {Object} itemNode
+	 */
+	
+	itemRendered: function(listWidget, itemModel, itemNode) {
+		// Whether to show the "mms delayed download" UI 
+		if (itemModel.status == this.Messaging.MessageStatus.RETRIEVING_CONTENT) {
+			Mojo.Log.info("itemRendered setup spinner")
+			this.controller.get('download-button_' + itemModel.messageId).mojo.activate();
+		} else if (itemModel.status == this.Messaging.MessageStatus.SUCCESS || itemModel.status == this.Messaging.MessageStatus.DELAYED_DELIVERY) {
+			var dlbutton = this.controller.get('download-button_' + itemModel.messageId);
+			if (dlbutton !== undefined) {
+				dlbutton.mojo.deactivate();
+			}
+		}
+
+		if(itemModel.hasImageAttachment) {
+			var imageContainer = this.controller.get('HACKImage' + itemModel.messageId);
+		
+			for(var i=0; i<itemModel.imageData.length; i++) {
+				var imageData = itemModel.imageData[i];
+				var imageObject = new Image();
+
+				// inject the image into the dom after it has been loaded so we can fix the scroll position
+				imageObject.onload = this.mmsImageOnLoad.curry(imageObject, imageContainer, itemModel, itemNode);;
+				imageObject.onerror = this.mmsImageOnError.curry(imageObject);
+
+				imageObject.className = "MMSImageObject";
+				imageObject.setAttribute("originalSrc",imageData.originalImagePath);
+				imageObject.src = imageData.resizedImagePath;
+
+				// append file name/size info below the image
+				//var imageFooterContent = Mojo.View.render({object:imageData, template:this.messageTemplatePath + 'mms-image'});
+				//imageContainer.insert(imageFooterContent);
+			}
+		}
+		
+		if(itemModel.hasAudioAttachment) {
+			var audioElementCache = this.getAudioElementCacheInstance();
+			if (audioElementCache.hasElement(itemModel.messageId)) {
+				this.controller.get(itemNode).replace(audioElementCache.get(itemModel.messageId));
+			} else {
+				var partHTML = Mojo.View.render({
+					collection: itemModel.audioData,
+					template: this.messageTemplatePath + 'mms-audio'
+				});
+				var audioElement = this.controller.get('HACKAudio' + itemModel.messageId);
+				if(audioElement)
+					audioElement.update(partHTML);
+				else
+					Mojo.Log.info("ERROR: Unable to locate audio object");
+					
+				for(var i=0; i<itemModel.audioData.length; i++) {
+					var audio = itemModel.audioData[i];
+					// calling extendElement will tie the audio object to this scene.  When the scene is trashed,
+					// any audio objects will get GCed
+					audioElement = this.controller.get(audio.elementId);
+					var audioTag = AudioTag.extendElement(audioElement,this.controller,audio.path);
+					audioTag.autoplay = false;
+					
+					audioElement.observe('error', this.hackHandleAudioError);
+					
+				};
+				audioElementCache.add(itemModel.messageId,itemNode);
+			}	
+		}
+		
+		// Images are a special case because we adjust the scroll position in the image onload callback
+		if(itemModel.hasAttachmentData && !itemModel.hasImageAttachment) {
+			var currentBottom = this.getCurrentBottom();
+			if (currentBottom < this.MAX_BOTTOM_HEIGHT_FOR_SNAP) {
+				this.debouncedRevealBottom();	
+			}
+		}
+		
+		this.debouncedListLoaded();
+	},
+	
+	// Since the audio error event does not bubble up, we cannot currently listen for this
+	// event on this list.  To avoid memory leaks we will use this unbound function to look up
+	// the current scene and pop up the alert dialog for the error
+	hackHandleAudioError: function(error) {
+		var stageController = Mojo.Controller.getAppController().getStageController(MainStageName);
+		if(stageController) {
+			var sceneStack = stageController.getScenes();
+			for(var i=0; i<sceneStack.length; i++) {
+				if(sceneStack[i].sceneName == "chatview") {
+					var f = sceneStack[i].assistant.handleAudioError;
+					if(f) {
+						f.apply(sceneStack[i].assistant, [error]);
+					}
+				}
+			}
+		}
+	},
+	
+	handleAudioError: function(error) {
+		this.controller.showAlertDialog({
+			onChoose: function() {
+			},
+			title: $L("Error"),
+			message: $L("There was an error attempting to play the selected audio attachment"),
+			preventCancel: false,
+			choices: [{
+				label: $L('Dismiss'),
+				value: 'Dismiss'
+			}]
+		});	
+	},
+	
+	mmsImageOnLoad: function(imageObject, imageContainer, itemModel, itemNode) {
+		var referenceItem = this.getOnScreenItem();
+		var referenceItemOffset;
+
+		if(referenceItem) {
+			referenceItemOffset = Mojo.View.viewportOffset(referenceItem).top;	
+		}
+		
+		imageContainer.appendChild(imageObject);
+		
+		if(referenceItem) {
+			var delta = referenceItemOffset-Mojo.View.viewportOffset(referenceItem).top;
+			if(delta) {
+				this.controller.sceneScroller.mojo.adjustBy(0,delta);
+			} else { 
+				// special case for last item in the list:
+				// - sometimes injecting an image will not affect the position of the item being watched.
+				// - This is only a problem for the last item in the list since we know that we are not
+				//   watching an element below it
+				// - This special case only applies if the last item is visible on screen
+				
+				var nodeTop = Mojo.View.viewportOffset(itemNode).top;
+				var isNodeVisible = (nodeTop >= 0 && nodeTop <= this.controller.window.innerHeight);
+				
+				if(isNodeVisible) {
+					var lastListItem = this.chatListWidget.mojo.getItems(this.chatListWidget.mojo.getLength()-1,1)[0];
+					if(lastListItem && lastListItem.messageId == itemModel.messageId) { 
+						this.controller.sceneScroller.mojo.adjustBy(0,-(itemNode.offsetHeight));
+					}
+				}
+			}
+		}
+		
+		imageObject.onload = null;
+		imageObject.onerror = null;
+	},	
+	
+	mmsImageOnError: function(imageObject) {
+		if(!imageObject.hasError) {		// set a property on the image object to indicate we have already encountered an error
+			imageObject.hasError = true;	// this prevents an infinite loop if brokenImage.png were to be missing
+			// loading the brokenImage will fire the onload callback and will clean up the onload/onerror observers
+			imageObject.src = "images/brokenImage.png";	
+		} else {
+			// this will only get called if the brokenImage is not able to be loaded
+			imageObject.onload = null;
+			imageObject.onerror = null;		
+		}
+		
+	},
+
+	debouncedListLoaded: function() {
+		if(!this.initialLoadComplete) {
+			if (this.listLoadedTimer) {
+				clearTimeout(this.listLoadedTimer);
+			}
+			this.listLoadedTimer = setTimeout(this.listLoadedTimerFn, 1000);
+		}	
+	},
+	
+	_debouncedListLoadedHelper: function() {
+		this.fixListScrollPositionOnLoad();
+		this.initialLoadComplete = true;
+	},
+	
+	
+	debouncedRevealBottom: function() {
+		this.revealBottomHack(); // reveal bottom right away
+		// delay revealing bottom so attachments have time to load
+		if (this.revealerTimer) {
+			clearTimeout(this.revealerTimer);
+		}
+		this.revealerTimer = setTimeout(function(){
+			this.revealBottomHack();
+		}.bind(this), 200);		
+	},
+	
+	getCurrentBottom: function() {
+		if(!this.controller) {
+			return;
+		}
+		var scrollState = this.controller.sceneScroller.mojo.getScrollPosition().top;
+		var sceneHeight = this.controller.sceneElement.getHeight();
+		var scrollerHeight = this.controller.sceneScroller.mojo.scrollerSize().height;
+		var bottom = Math.abs(-scrollState + scrollerHeight - sceneHeight);
+		return bottom;
+	},
+	
+	preFormatChatList: function(listWidget, stuff){
+		var needToInstantiateButtons = false;
+		for(var i=0; i<stuff.list.length; i++) {
+			var msg = stuff.list[i];
+			if(msg.summary && !ChatFlags.isTransient(msg.flags)) {
+				msg.summary = msg.summary.escapeHTML();
+				msg.summary = PalmSystem.runTextIndexer(msg.summary);
+			}
+
+			// Need to do setupWidget of the button here since activityButton only works before the
+			// button's setup() function is called.
+			if (msg.status == this.Messaging.MessageStatus.DELAYED_DELIVERY || msg.status == this.Messaging.MessageStatus.RETRIEVING_CONTENT) {
+				msg.label = $L("Download MMS");
+				this.controller.setupWidget('download-button_' + msg.messageId, {type:Mojo.Widget.activityButton}, msg);
+				needToInstantiateButtons = true;
+			}
+
+			if(msg.messageText && !ChatFlags.isTransient(msg.flags)) {
+				// escape the text we sent since user may have added html markup.
+				// Inbound messages are sanitized in the messaging service (to allow <u>, <i>, etc)
+				if (ChatFlags.isOutgoing(msg.flags)) {
+					msg.messageText = msg.messageText.escapeHTML();
+				}
+				msg.messageText = PalmSystem.runTextIndexer(msg.messageText);
+			}
+			
+			var transport = this.Messaging.transports.getTransportByName(msg.messageServiceName);
+			msg.transportClass = transport.className;
+			//msg.transportLabel = transport.secondaryDisplayName;
+				
+			var d = new Date();
+			d.setTime(msg.deviceTimeStamp);     
+			msg.niceDate = BucketDateFormatter.getDateBucket(d,true,true); // this used to use msg.timeStamp - changed 2008-11-05
+			
+			// divider hack - round to the nearest 5 minutes
+			// we have to do this because the list divider implementation does not allow a divider
+			// to have knowledge about other dividers
+		 	var deviceTimeStampMinutes = d.getMinutes();
+			d.setMinutes((deviceTimeStampMinutes - (deviceTimeStampMinutes % 5)));
+			d.setSeconds(0);
+			msg.dividerText = msg.transportClass + BucketDateFormatter.getDateBucket(d,true,true);
+	
+			// if the INCOMING message was sent longer than 10 minutes before it arrived on device,
+			// add sent date to indicate that this delay happened
+			if(!ChatFlags.isOutgoing(msg.flags) && msg.deviceTimeStamp && msg.timeStamp && (msg.deviceTimeStamp-msg.timeStamp) > (1000*60*10)) {
+				var d = new Date();
+				var today = d.getTime();
+				d.setTime(msg.timeStamp);
+				var sentTimeStamp = d;
+				
+				// Only show the message sent time if it is less than two days old
+				// from when it arrived on device
+				if(today-msg.timeStamp <= (1000*60*60*24*2)) {
+					msg.timeStampDeltaMsg = new Template($L("Message Sent: #{dateTime}")).evaluate({dateTime:Mojo.Format.formatDate(sentTimeStamp,'short')});
+				}		
+			}
+
+			if (msg.callbackNumber) {
+				msg.callbackNumber = PalmSystem.runTextIndexer(msg.callbackNumber);
+				var template = new Template($L("Call back #: #{number}"));
+				msg.callbackNumberText = template.evaluate({
+					number: MessagingUtils.formatPhoneNumber(msg.callbackNumber)
+				});
+			}
+			
+			msg.statusClass = this.Messaging.MessageStatus.getStatusClass(msg.status);
+			
+			if (msg.priority && msg.priority > 0) 
+				msg.messageTextClass = "priority"
+			else 
+				msg.messageTextClass = msg.statusClass;
+			
+			// If we have a failed SMS with no summary or mesage, then display a canned error message
+			if(msg.messageType) {
+				var messageTypeLowerCase = msg.messageType.toLowerCase();
+				if (messageTypeLowerCase == "sms" && (msg.status == this.Messaging.MessageStatus.FAILED || msg.status == this.Messaging.MessageStatus.UNDELIVERABLE) && msg.summary.length == 0 && msg.messageText.length == 0) {
+					msg.messageText = $L("This message has an error.");
+				}
+				
+				if (messageTypeLowerCase == "mms" && msg.status == this.Messaging.MessageStatus.FAILED && !ChatFlags.isOutgoing(msg.flags)) {
+					msg.messageText = $L("Failed to download msg");
+				}
+			}
+			var tmpClass = [];
+			
+			if (ChatFlags.isOutgoing(msg.flags)) {
+				tmpClass.push("my-chat");
+			// Disabling MY avatar because we are not doing this for 1.0  2008-11-05
+			//msg.avatar = this.myAvatar || 'images/my-avatar.png';
+			} else {
+				tmpClass.push("their-chat");
+				msg.avatar = this.avatarHash[msg.fromAddress] || this.contactAvatar || "images/list-view-default-avatar.png";
+			}				
+			msg.imAvatarOverlay = "images/list-view-avatar-frame.png";				
+			
+			// isTransient is set on messages that we added to the chat when the account
+			// on the current transport goes online/offline
+			if (ChatFlags.isTransient(msg.flags)) {
+				tmpClass.push("status-message");
+			}
+			
+			if (msg.status == this.Messaging.MessageStatus.FAILED || msg.status == this.Messaging.MessageStatus.UNDELIVERABLE) {
+				tmpClass.push("error");
+				msg.errorContent = Mojo.View.render({object:msg, template:this.messageTemplatePath + 'message-error'});
+			}
+			msg.css_class = tmpClass.join(" ");
+			
+			// render parts of the message from templates so we don't have lots of hidden divs that impact perf
+			msg.messageContents = '';		
+			if(msg.timeStampDeltaMsg) {
+				msg.messageContents += Mojo.View.render({object:msg, template:this.messageTemplatePath + 'delayed-message-timestamp'});
+			}
+			if(msg.summary) {
+				msg.messageContents += Mojo.View.render({object:msg, template:this.messageTemplatePath + 'message-summary'});
+			}
+			msg.messageContents += Mojo.View.render({object:msg, template:this.messageTemplatePath + 'message-text'});
+			if(msg.callbackNumberText) {
+				msg.messageContents += Mojo.View.render({object:msg, template:this.messageTemplatePath + 'callback-number'});
+			}
+		}
+		
+		// Only take the hit of instantiateChildWidgets if a download button had to be setup. 
+		if (needToInstantiateButtons === true) {
+			this.controller.instantiateChildWidgets(listWidget);
+		}
+	},
+	
+	buildMMSParts: function(id, flags, offset, parts){
+		var audioData = [];
+		var imageData = [];
+		var partCount = 0;
+		var partId = id + "_" + partCount;
+			
+		var items = this.chatListWidget.mojo.getItems(offset,1);
+		var item = items[0];
+		if(!item) {
+			return;
+		}
+		var referenceItem = this.getOnScreenItem(id);
+		var referenceItemOffsetBeforeUpdate;
+		var referenceItemOffsetAfterUpdate;
+
+		var mmsContent = '';
+
+		for(var i=0; i<parts.list.length; i++) { 
+			var part = parts.list[i];
+			//console.log("PART: " + Object.toJSON(part) + " PART ID: " + partId);
+
+			if (part.size && part.size > 0) { // convert the byte value into KB
+				var size = Math.round((part.size / 1024) * 10) / 10;
+				var sizeUnit = "K";
+				// if more than 999 KB then convert to MB to save screen space
+				if(size >= 1000) {
+					size = Math.round((part.size / (1024*1024)) * 10) / 10;
+					sizeUnit = "M";
+				}
+
+				part.size = new Template($L("#{size}#{sizeUnit}")).evaluate({
+					size: size,
+					sizeUnit: sizeUnit
+				});
+			} else {
+				part.size = '';
+			}
+			
+			if(!part.mimeType) {
+				part.mimeType = '';
+			}
+			
+			if (part.mimeType.substring(0, 5) == 'image') {
+				item.hasImageAttachment = true;
+				var imagePart = {
+					elementId: "mmsImage_" + partId,
+					resizedImagePath: MessagingUtils.extractfs(part.uri,{width:240,height:300,crop:3}),
+					originalImagePath:  part.uri
+				};
+				// if outgoing, hide the size + display name.
+				if(ChatFlags.isOutgoing(flags)) {
+					imagePart.size = '';
+					imagePart.displayName = '';
+				} else {
+					imagePart.size = part.size;
+					imagePart.displayName = part.displayName;					
+				}			
+				imageData.push(imagePart);
+			} else if (part.mimeType.substring(0, 5) == 'audio') {
+				// queue up the audio file to be loaded after the content has been drawn in our itemRendered callback
+				item.hasAudioAttachment = true;
+				audioData.push({
+					elementId: "mmsAudio_" + partId,
+					path: MessagingUtils.systemPathToLocalURL(part.uri),
+					displayName: part.displayName,
+					size: part.size
+				});
+			} else if (part.mimeType.substring(0, 5) == 'video') {
+				part.fileInfo = part.displayName;
+				part.uri = MessagingUtils.systemPathToLocalURL(part.uri);
+				part.mmsTypeClass = 'mms-video';
+				mmsContent += Mojo.View.render({object:part, template:this.messageTemplatePath + 'mms-video'});
+			} else if (part.mimeType == "text/plain" && !part.uri) {
+				if(part.partText) {
+					part.MMSMessageText = part.partText.escapeHTML();
+					part.MMSMessageText = PalmSystem.runTextIndexer(part.MMSMessageText);
+				}
+				mmsContent += Mojo.View.render({object:part, template:this.messageTemplatePath + 'mms-text'});
+			} else if (part.mimeType.substring(0, 4) == 'text') { // if text but not plain (vcard/vcal)
+				var textType = part.mimeType.substring(5).toLowerCase();
+				if(textType == 'x-vcalendar')
+					part.mmsTypeClass = "mms-vcal";
+				else if(textType == 'x-vcard')
+					part.mmsTypeClass = "mms-vcard";
+				mmsContent += Mojo.View.render({object:part, template:this.messageTemplatePath + 'mms-generic'});
+			} else if (part.mimeType != "application/smil") { // filter out the smil
+				// This is an attachment that we don't handle -> just display the name
+				mmsContent += Mojo.View.render({object:part, template:this.messageTemplatePath + 'mms-generic'});
+			}			
+			partId = id + "_" + (++partCount);
+		}
+
+		item.hasAttachmentData = true; // data for attachments have been put on the item model
+		// Special cases for attachments that are handled in the itemRendered callback
+		if(item.hasImageAttachment) {
+			mmsContent += Mojo.View.render({object:{messageId:id}, template:this.messageTemplatePath + 'mms-image-container'});
+		}
+		if(item.hasAudioAttachment) {
+			mmsContent += Mojo.View.render({object:{messageId:id}, template:this.messageTemplatePath + 'mms-audio-container'});
+		}
+		
+		// store the image/audio data that will be used in the itemRendered callback
+		item.imageData = imageData;
+		item.audioData = audioData;
+		item.mmsAttachments = mmsContent; // inject all the attachment content that we just built
+
+		// Adjust the scroll position if it changes after calling noticeUpdatedItems
+		if(referenceItem) {
+			referenceItemOffsetBeforeUpdate = Mojo.View.viewportOffset(referenceItem).top;
+		}
+
+		this.chatListWidget.mojo.noticeUpdatedItems(offset,[item]);
+
+		if(referenceItem) {
+			referenceItemOffsetAfterUpdate = Mojo.View.viewportOffset(referenceItem).top;
+			if(referenceItemOffsetBeforeUpdate != referenceItemOffsetAfterUpdate) {
+				this.controller.sceneScroller.mojo.adjustBy(0,(referenceItemOffsetBeforeUpdate - referenceItemOffsetAfterUpdate));
+			}
+		}
+	},
+	
+	getOnScreenItem: function(excludeId) {
+		var loadedItems = this.chatListWidget.querySelectorAll(".chat-entry");	
+		var windowHeight = this.controller.window.innerHeight;
+		var node;
+		var closestOffset;
+		var bestNode;
+		var topOffset;
+		if(loadedItems) {
+			for(var i=loadedItems.length-1; i>=0; i--) {
+				node = loadedItems[i];
+				var messageId = node.getAttribute('messageId');
+				if(node) {
+					topOffset = Mojo.View.viewportOffset(node).top;
+					if(topOffset >= 0 && topOffset <= windowHeight && (!excludeId || excludeId != messageId)) {
+						return node;
+					} else {
+						var adjustedOffset;
+						if(topOffset < 0) {
+							adjustedOffset = Math.abs(topOffset);
+						} else if(topOffset > this.controller.window.innerHeight) {
+							adjustedOffset = (topOffset - windowHeight);		
+						}
+						if(!closestOffset || closestOffset > adjustedOffset) {
+							closestOffset = adjustedOffset;
+							bestNode = node;
+						}
+						
+					}
+				}
+			}
+		}
+		return bestNode;
+	},
+	
+	handleMessageDelete: function(event){
+		this.listReset = true;
+		MessagingMojoService.deleteMessage(this.controller, event.item.messageId);
+	},
+	
+	handleMessageDeleteFromContextMenu: function(messageId, index){
+		this.controller.showAlertDialog(
+		{
+	        onChoose: function(value) 
+			{
+				if (value == 'delete')
+				{
+					this.chatListWidget.mojo.noticeRemovedItems(index, 1);
+			
+					this.listReset = true;
+					MessagingMojoService.deleteMessage(this.controller, messageId);
+				}
+			},
+	        title: $L("Delete Message"),
+	        message: $L("Are you sure you want to delete this message?"),
+	        choices:
+			[
+	             {label:$L('Delete'), value:'delete', type:'negative'},
+	             {label:$L("Cancel"), value:'cancel'}
+	        ]
+        });
+		
+	},
+
+	/**
+	 * handle context menu selection after tap on SMS/IM message
+	 * 
+	 * @param {Object} text
+	 * @param {Object} messageId
+	 * @param {Object} index
+	 * @param {Object} value
+	 */
+	handleContextMenuSelectSmsIm: function(text, messageId, index, value){
+		Mojo.Log.info("+++++handleContextMenuSelectSmsIm");
+		
+		Mojo.Log.info("value " + value);
+		
+		if (value == 'forward-cmd'){
+			var composeParams = {
+				messageText: text,
+				focusWindow: true,
+				launchedAsForward: true
+			};
+				
+			this.controller.stageController.pushScene("compose", composeParams);
+		} else if (value == 'copy-cmd'){
+			Mojo.Log.info("text to copy : " + text);
+			this.addTextToClipboard(text);
+		} else if (value == 'delete-cmd'){
+			this.handleMessageDeleteFromContextMenu(messageId, index);
+		} 
+	},
+	
+	/**
+	 * parse text out of MMS message for copying to the clipboard
+	 * 
+	 * @param {Object} chatBalloon
+	 */
+	parseOutText: function(chatBalloon){
+		
+		var textToClipboard = "";
+		var lineWritten = false;
+		for (var i = 0; i < chatBalloon.children.length; i++) {
+			var child = chatBalloon.children.item(i);
+			
+			if (child.hasClassName('messageSummary')) {
+				textToClipboard += child.innerText;
+				lineWritten = true;
+			}
+			else 
+				if (child.hasClassName('MMSPlaceholder')) {
+				
+					for (var j = 0; j < child.children.length; j++) {
+						var grandchild = child.children.item(j);
+						
+						if (grandchild.hasClassName('MMSMessage')) {
+							if (lineWritten) {
+								textToClipboard += "\n";
+							}
+							textToClipboard += grandchild.innerText;
+							lineWritten = true;
+						}
+					}
+				}
+			
+			if (lineWritten) {
+				Mojo.Log.info("textToClipboard : " + textToClipboard);
+			}else {
+				Mojo.Log.info("no text found to write");
+			}
+		}
+		
+		return textToClipboard;
+	},
+	
+	/**
+	 * context menu handler for tap on MMS in chat list
+	 * 
+	 * @param {Object} paramsIn
+	 * @param {Object} value
+	 */
+	handleContextMenuSelectMms: function(paramsIn, value){
+		Mojo.Log.info("+++++handleContextMenuSelectMms");
+		
+		if (value == 'forward-cmd'){
+				
+			composeParams = {
+				messageId: paramsIn.messageId,
+				chatBalloonDiv: paramsIn.html,
+				focusWindow: true
+			};
+
+			this.controller.stageController.pushScene("mmsforward", composeParams);	
+		} else if (value == 'view-image-cmd'){
+			this.controller.stageController.pushScene('imageview', paramsIn.filePath);	
+		}else if (value == 'play-video-cmd'){		
+			var args = {
+				appId: "com.palm.app.videoplayer",
+				name: "nowplaying"
+			};
+			var videoPlayParams = {
+				target: paramsIn.filePath,
+				title: paramsIn.fileName
+			};
+			this.controller.stageController.pushScene(args, videoPlayParams); 			
+			return;
+		}else if (value == 'add-contact-cmd'){
+			MessagingMojoService.launchFile(this.controller, 'text/x-vcard', 'file://'+paramsIn.filePath);
+			return;		
+
+		}else if (value == 'add-calendar-cmd'){
+			MessagingMojoService.launchFile(this.controller, 'text/x-vcalendar', 'file://'+paramsIn.filePath);
+			return;				
+		}else if (value == 'delete-cmd'){
+			this.handleMessageDeleteFromContextMenu(paramsIn.messageId, paramsIn.index);
+		}else if (value == 'copy-text-cmd'){
+			this.addTextToClipboard(paramsIn.copyText);
+		}
+	},
+	
+	/**
+	 * handler for message tap within chat list
+	 * 
+	 * @param {Object} event
+	 */
+	handleMessageTap: function(event){
+		
+		/*
+		 * Special handling for delayed MMS status. First tap starts download.
+		 * If the request is in progress, then ignore the tap
+		 */
+		var status = event.item.status;
+		if (status == this.Messaging.MessageStatus.DELAYED_DELIVERY) {
+			event.item.label = $L("Downloading MMS");
+			event.item.status = this.Messaging.MessageStatus.RETRIEVING_CONTENT;
+			this.controller.get('download-button_' + event.item.messageId).mojo.activate();
+			this.controller.modelChanged(event.item);
+
+			var failHandler = function(item, error) {
+				Mojo.Log.error("failHandler %i %j", item.messageId, error)
+				item.status = this.Messaging.MessageStatus.DELAYED_DELIVERY
+				this.controller.get('download-button_' + event.item.messageId).mojo.deactivate();
+				item.label = $L("Download MMS");
+				this.controller.modelChanged(item);
+			}.bind(this, event.item);
+			MessagingMojoService.downloadDelayedMessage(this.controller, event.item.messageId, Mojo.doNothing, failHandler);
+			return;
+		} else if (status == this.Messaging.MessageStatus.RETRIEVING_CONTENT) {
+			Mojo.Log.info("TODO: handleMessageTap -- in the process of retrieving mms");
+			return;
+		}
+
+		/*
+		 * see if they tapped a link, phone number, email etc.
+		 */
+		var eventTarget = this.controller.get(event.originalEvent.target);
+		if ( (eventTarget.tagName === "A") && 
+						(eventTarget.href !== undefined) ){
+			Mojo.Log.info("link tapped no context menu");
+			return;				
+		}
+		
+		/*
+		 * look to see if they tapped error target first
+		 */
+		if (eventTarget.hasClassName('error')){
+			Mojo.Log.info("hit error target")
+			MessagingUtils.simpleListClick(this.controller.get(event.originalEvent.target), "chatRow", function(targetRow){
+				var messageData = {
+					errorCode: targetRow.getAttribute("errorCode"),
+					status: targetRow.getAttribute("status"),
+					messageId: targetRow.getAttribute("messageId"),
+					flags: targetRow.getAttribute("flags"),
+					messageType: targetRow.getAttribute("messageType")
+				};
+			
+				MessagingMojoService.getMessageErrorInfo(this.controller, messageData.messageId, messageData.flags, this.handleMessageErrorPopup.bind(this,messageData));
+		
+			}.bind(this), false);
+			return;
+		}
+
+		/*
+		 * Action determined on where where in the chat row they tapped 
+		 */
+		var chatRowTarget = MessagingUtils.getClassUpChain(eventTarget,'chatRow');
+		if (chatRowTarget){
+			Mojo.Log.info("got chat row tap");
+			
+			var messageId =  chatRowTarget.getAttribute("messageId")
+			var messageType =  chatRowTarget.getAttribute("messageType")
+			var index = chatRowTarget._mojoListIndex;
+			
+			
+			Mojo.Log.info("messageId " + messageId);
+			Mojo.Log.info("messageType " + messageType);
+			Mojo.Log.info("index " + index);
+			
+			var composeParams;
+			if ((messageType == "SMS") || (messageType == "IM") ) {	
+			
+				var messageTarget = MessagingUtils.getClassUpChain(eventTarget,'chat-balloon-wrapper');
+				if(messageTarget == null){
+					messageTarget = this.searchDownForChatBalloonWrapper(chatRowTarget);
+				}
+				
+				if (messageTarget == null){
+					Mojo.Log.error("unable to find chat-baloon-wrapper");
+					return;
+				}
+						
+				this.controller.popupSubmenu({
+  					onChoose:  this.handleContextMenuSelectSmsIm.bind(this, messageTarget.innerText, messageId, index),
+  					placeNear: eventTarget.target,
+  					items: [
+    					{label: $L('Forward'), command: 'forward-cmd'},
+						{label: $L('Copy Text'), command: 'copy-cmd'},
+						{label: $L('Delete'), command: 'delete-cmd'}
+    				]
+  				});
+			
+			}else if (messageType == "MMS") {
+				
+				Mojo.Log.info("++++++MMS Text content was " + eventTarget.textContent);
+				
+				/*
+				 * chat-balloon-wrapper contains the visible div of the MMS which 
+				 * is the right level to look for text to copy, or send on to the
+				 * forward scene to show the MMS
+				 */
+				var chatBalloonWrapper = MessagingUtils.getClassUpChain(eventTarget,'chat-balloon-wrapper');
+				if (chatBalloonWrapper == null) {
+					chatBalloonWrapper = this.searchDownForChatBalloonWrapper(chatRowTarget);
+				}
+				
+				if (chatBalloonWrapper == null){
+					Mojo.Log.error("unable to find chat-baloon-wrapper");
+					return;
+				}
+				
+				/*
+				 * get the copy text up front. we need to set the text
+				 * before the popup context menu because the message tapped
+				 * could be in process to be sent and may resolve while
+				 * the pop up menu is up thus invalidating the list element
+				 * the user tapped. its such a small amount of text to 
+				 * parse out that this should not be a problem
+				 */
+				var copytext = this.parseOutText(chatBalloonWrapper);
+				Mojo.Log.info("copytext " + copytext);
+				
+				var params = {
+					html: chatBalloonWrapper.innerHTML,
+					copyText: copytext,
+					messageId: messageId,
+					index:index
+				};
+				
+				/*
+				 * Check for the type of element the user tapped one by one and show the
+				 * appropriate context menu
+				 */
+				
+				var mmsTarget = MessagingUtils.getClassUpChain(eventTarget,'MMSImageObject');
+				if(mmsTarget) {
+					
+					params.filePath = mmsTarget.getAttribute('originalSrc');
+					
+					this.controller.popupSubmenu({
+  						onChoose:  this.handleContextMenuSelectMms.bind(this, params),
+  						placeNear: mmsTarget,
+  						items: [
+    						{label: $L('View'), command: 'view-image-cmd'},
+    						{label: $L('Forward'), command: 'forward-cmd'},
+							{label: $L('Copy Text'), command: 'copy-text-cmd'},
+							{label: $L('Delete'), command: 'delete-cmd'}
+    					]
+  					});	
+					
+					return;
+				} 
+				
+				mmsTarget = MessagingUtils.getClassUpChain(eventTarget,'mms-video');
+				if (mmsTarget) {
+
+					params.filePath = mmsTarget.getAttribute('filePath');
+					params.fileName = mmsTarget.getAttribute('fileInfo');
+					
+					this.controller.popupSubmenu({
+  						onChoose:  this.handleContextMenuSelectMms.bind(this, params),
+  						placeNear: mmsTarget,
+  						items: [
+    						{label: $L('Play'), command: 'play-video-cmd'},
+    						{label: $L('Forward'), command: 'forward-cmd'},
+							{label: $L('Copy Text'), command: 'copy-text-cmd'},
+							{label: $L('Delete'), command: 'delete-cmd'}
+    					]
+  					});
+					return;
+				}	
+
+				mmsTarget = MessagingUtils.getClassUpChain(eventTarget,'mms-vcard');
+				if (mmsTarget){
+					
+					params.filePath = mmsTarget.getAttribute('filePath');
+					
+					this.controller.popupSubmenu({
+  						onChoose:  this.handleContextMenuSelectMms.bind(this, params),
+  						placeNear: mmsTarget,
+  						items: [
+							{label: $L('Add to Contacts'), command: 'add-contact-cmd'},
+    						{label: $L('Forward'), command: 'forward-cmd'},
+							{label: $L('Copy Text'), command: 'copy-text-cmd'},
+							{label: $L('Delete'), command: 'delete-cmd'}
+    						]
+  					});	
+					return;
+				}
+				
+				/*
+				mmsTarget = MessagingUtils.getClassUpChain(eventTarget,'mms-vcal');
+				if (mmsTarget){
+					
+					params.filePath = mmsTarget.getAttribute('filePath');
+					
+					this.controller.popupSubmenu({
+  						onChoose:  this.handleContextMenuSelectMms.bind(this, params),
+  						placeNear: mmsTarget,
+  						items: [
+							{label: $L('Add to Calendar'), command: 'add-calendar-cmd'},
+    						{label: $L('Forward'), command: 'forward-cmd'},
+							{label: $L('Copy Text'), command: 'copy-text-cmd'},
+							{label: $L('Delete'), command: 'delete-cmd'},
+    					]
+  					});	
+					return;
+				}*/
+				
+				mmsTarget = MessagingUtils.getClassUpChain(eventTarget,'mms-audio-container');
+				if (mmsTarget){
+					Mojo.Log.info("audio target, ignore");
+					/*
+					 * Audio object plays inline and I cant really pop a contect menu up
+					 */
+					return;
+				}
+				
+				/*
+				 * default behavior
+				 */	
+				this.controller.popupSubmenu({
+  					onChoose:  this.handleContextMenuSelectMms.bind(this, params),
+  					placeNear: eventTarget.target,
+  					items: [
+    					{label: $L('Forward'), command: 'forward-cmd'},
+						{label: $L('Copy Text'), command: 'copy-text-cmd'},
+						{label: $L('Delete'), command: 'delete-cmd'}
+    				]
+  				});	
+				
+		
+			}
+		
+		}
+			
+	},
+	
+	/**
+	 * Search out the chat-balloon-wrapper element starting at the chat-row
+	 * 
+	 * @param {Object} chatRowTarget
+	 */
+	searchDownForChatBalloonWrapper: function(chatRowTarget){
+		Mojo.Log.info("tap above level of chat-balloon-wrapper, look inside");
+					
+		for (var i=0; i < chatRowTarget.children.length; i++){
+			var palmRowWrapper = chatRowTarget.children.item(i);
+
+			if (palmRowWrapper.hasClassName('palm-row-wrapper')){
+				for (var j=0; j < palmRowWrapper.children.length; j++){
+					var chatBalloon = palmRowWrapper.children.item(j);
+					if (chatBalloon.hasClassName('chat-balloon')){
+						for (var k = 0; k < chatBalloon.children.length; k++) {
+							var chatBalloonWrapper = chatBalloon.children.item(k);
+							if (chatBalloonWrapper.hasClassName('chat-balloon-wrapper')){
+								Mojo.Log.info("found chat-balloon-wrapper");
+								return chatBalloonWrapper;
+							}
+						}
+					}
+				}
+			}
+		}
+		
+		return null;
+	},
+	
+
+	handleMessageErrorPopup: function(messageData,messageErrorData) {
+		var that = this;
+		var dialogChoices = [];
+		var retryTransport = null;	
+		var title = undefined;	
+		
+		Mojo.Log.error("*** ERROR CODE: " + messageData.errorCode + " status: " + messageData.status);
+		
+		// MMS ERRORS
+		if (messageData.status != this.Messaging.MessageStatus.SUCCESS && messageData.errorCode && messageData.errorCode > 0) {
+			
+			if (ChatFlags.isOutgoing(messageData.flags) ){
+				title =$L("Unable To Send Message");
+			}else{
+				title =$L("Unable to Download Message");
+			}
+			
+			// provide a retry option for failed incoming MMS messages
+			if(messageData.status == this.Messaging.MessageStatus.FAILED && !ChatFlags.isOutgoing(messageData.flags) && messageData.messageType == "MMS") {
+				dialogChoices.push({
+					label: $L('Retry message fetch'),
+					value: 'retry'
+				});
+			} else if(messageData.status == this.Messaging.MessageStatus.FAILED && ChatFlags.isOutgoing(messageData.flags) && messageData.messageType == "MMS") {
+				
+				if(messageErrorData && messageErrorData.list) {
+					for(var i=0; i<messageErrorData.list.length; i++) {
+						var recipient = messageErrorData.list[i];
+						var transport = that.getTransportFromPhoneNumber(recipient.address);
+						if(transport) {
+							retryTransport = transport;
+						}
+					}
+					if(retryTransport) {
+						dialogChoices.push({
+							label: $L('Send again'),
+							value: 'sendagain'
+						});
+					}									
+				}
+			}
+			
+			dialogChoices.push({
+				label: $L('Ok'),
+				value: 'Close'
+			});				
+			
+
+			this.controller.showAlertDialog({
+				onChoose: function(messageId,choice){
+					if(choice == 'retry') {
+						MessagingMojoService.reFetch(this.controller,messageId);
+					} else if(choice == 'sendagain') {
+						var params = {
+						    chatThreadId: this.chatThreadId,
+						    recipient:  retryTransport.value,
+						    messageText: "", // will be set in handleGetMessageDetails
+						    contactPointId: retryTransport.contactPointId
+						};
+						MessagingMojoService.getMMSParts(this.controller, messageId, this.handleErrorGetMMSPartsForSendAgain.bind(this, params));
+										
+					}						
+				}.bind(this,messageData.messageId),
+				title: title,
+				message: CONSTANTS.ERROR[messageData.errorCode],
+				preventCancel: false,
+				choices: dialogChoices
+			});
+		
+		// SMS Errors
+		} else if ((!messageData.errorCode || messageData.errorCode == 0) && (messageData.status == this.Messaging.MessageStatus.FAILED || messageData.status == this.Messaging.MessageStatus.UNDELIVERABLE)) {
+			var failure = [];
+			var success = [];
+			var pending = [];
+			var params = {
+				hasFailureClass: "hide",
+				hasSuccessClass: "hide",
+				hasPendingClass: "hide"
+			};
+	
+			if (messageErrorData.list && messageErrorData.list.length > 0) {
+				messageErrorData.list.each(function(recipient){
+					var recipientName = MessagingUtils.generateNameString(recipient);
+					var recipientErrorCode = (recipient.errorCode) ? recipient.errorCode.toLowerCase() : "";
+					if (recipientErrorCode == "success") {
+						success.push(recipientName);
+					} else if(recipientErrorCode == "pending") {
+						pending.push(recipientName);
+						var transport = that.getTransportFromPhoneNumber(recipient.address);
+						if(transport) {
+							retryTransport = transport;
+						}				
+					} else {
+						var transport = that.getTransportFromPhoneNumber(recipient.address);
+						if(transport) {
+							retryTransport = transport;
+						}						
+						
+						var causeCodeStr = "";
+						var tmp = "#{recipientName}";
+						var recipientError = that.Messaging.Error.getMessageErrorFromCode(recipientErrorCode);
+						if (recipient.causeCode && recipient.causeCode > 0) 	
+							causeCodeStr = new Template($L("(code: #{causeCode})")).evaluate({causeCode: recipient.causeCode});
+						if(recipientError)
+							tmp += " #{recipientError}";
+						if(causeCodeStr)
+							tmp += " #{causeCodeStr}";
+	
+						if(recipientErrorCode == "fdnrestricted") {
+							tmp += $L(" (FDN Restricted)");
+						}
+	
+						failure.push(new Template($L(tmp)).evaluate({
+							recipientName: recipientName,
+							recipientError: recipientError,
+							causeCodeStr: causeCodeStr
+						}));						
+					} 
+				});
+				if (failure.length > 0) {
+					params.hasFailureClass = "";
+					params.failureRecipients = new Template($L("Message failed to: #{failure}")).evaluate({
+						failure: failure.join(", ")
+					});
+				}
+				if (success.length > 0) {
+					params.hasSuccessClass = "";
+					params.successRecipients = new Template($L("Message successfully sent to: #{success}")).evaluate({
+						success: success.join(", ")
+					});
+				}
+				if (pending.length > 0) {
+					params.hasPendingClass = "";
+					params.pendingRecipients = new Template($L("Message will be sent to: #{pending}")).evaluate({
+						pending: pending.join(", ")
+					});
+				}
+			}
+		
+			var errorContent = Mojo.View.render({
+				object: params,
+				template: 'chatview/message-error'
+			});
+	
+			if(retryTransport && messageData.status == this.Messaging.MessageStatus.FAILED) {
+				dialogChoices.push({
+					label: $L('Send again'),
+					value: 'sendagain'
+				});
+			}
+			dialogChoices.push({
+				label: $L('Ok'),
+				value: 'Close'
+			});	
+	
+			this.controller.showAlertDialog({
+				onChoose: function(choice) {
+					if(choice == 'sendagain') {
+						var params = {
+						    chatThreadId: this.chatThreadId,
+						    recipient:  retryTransport.value,
+						    messageText: "", // will be set in handleGetMessageDetails
+						    contactPointId: retryTransport.contactPointId
+						};
+						MessagingMojoService.getMessageDetails(this.controller, messageData.messageId, this.handleErrorGetMessageDetailsForSendAgain.bind(this,params));					
+					}
+				}.bind(this),
+				message: errorContent,
+				allowHTMLMessage: true,
+				preventCancel: false,
+				choices: dialogChoices
+			});	
+		}	
+	},
+	
+	
+	// Called for SMS messages
+	handleErrorGetMessageDetailsForSendAgain: function(params, result) {
+		if(result && result.record && result.record.messageText) {
+			params.messageText = result.record.messageText;
+		}
+		this.sendMessageHelper(this.controller, params);
+		this.revealBottomHack(); // snap to the bottom when the user sends a message
+	},
+	
+	// Called for MMS messages
+	handleErrorGetMMSPartsForSendAgain: function(params, parts) {
+		params.summary = '';
+		for(var i=0; i<parts.list.length; i++) {
+			var part = parts.list[i];
+			if(part.mimeType) {
+				if (part.mimeType && part.mimeType == "text/plain" && !part.uri) {
+					if(part.partText) {
+						params.messageText = part.partText;
+					}
+				} else if (part.mimeType.substring(0, 5) == 'image') {
+					if(part.uri) {
+						params.attachment = part.uri;
+					}
+				} 
+			}
+		}
+		this.sendMessageHelper(this.controller, params);
+		this.revealBottomHack(); // snap to the bottom when the user sends a message	
+	},
+	
+	// iterate over our array of transports and look for one whose address matches
+	getTransportFromPhoneNumber: function(phoneNumber) {
+		for(var i=0; i<this.transports.length; i++) {
+			var transport = this.transports[i];
+			if(!transport.serviceName && transport.value == phoneNumber) {
+				return transport;
+			}	
+		}
+		return null;
+	},	
+	
+	setTextFieldValue: function(value) {
+		if(value != undefined) {
+			this.messageTextWidgetModel.value = value;
+			this.controller.modelChanged(this.messageTextWidgetModel);
+			// make sure the right action button is showing if there is any text in the textbox
+			this.handleTextAreaChange();			
+		} 
+	},
+
+	handleTextAreaKeyUp: function(event) {
+		if (event && Mojo.Char.isEnterKey(event.keyCode)) {
+			this.considerForSend();
+			Event.stop(event);
+		}		
+	},
+
+	handleTextAreaChange: function() {
+		if (this.messageTextElement && this.messageTextElement.value == '') {
+			this.actionButton.removeClassName('textentry');
+			this.actionButton.addClassName('empty');
+		} else {
+			this.actionButton.addClassName('textentry');
+			this.actionButton.removeClassName('empty');
+		}
+		
+		this.characterCounter.deferredResetCount();	
+	},
+	
+	// This method is called when the send button is clicked or the enter key is fired in the textbox
+	// This is our fallback logic when attempting to send to an offline user
+	considerForSend: function(forceSendIfOffline){
+		// Make sure that forceSendIfOffline is really a boolean in the falsy case
+		// This will sometimes be an object because we pass this method directly when we observe
+		// Mojo.Event.tap on the send button
+		if(forceSendIfOffline && forceSendIfOffline != true)
+			forceSendIfOffline = false;		
+		
+		// prevent blank messages from going through
+		var message = this.messageTextElement.value.strip();
+		if ((!this.attachment && message.length > 0) || this.attachment) {
+			// if the current message is longer than the max size, alert the user and block the send action
+			if(!this.characterCounter.isValidLength()) {
+				this.controller.showAlertDialog({
+					onChoose: function(){},
+					title: $L("Message length error"),
+					message: $L("The message that you have entered is larger than the allowed size."),
+					preventCancel: false,
+					choices: [{
+						label: $L('Ok'),
+						value: 'Close'
+					}]
+				});
+				return;
+			}
+			
+			// If the current transport is IM + it has gone offline + you are not offline, display a dialog to choose another transport
+			// we will also give the user an option to force the send
+			var account = this.Messaging.IMAccounts.getAccountFromAccountTagOrServiceName(this.selectedTransport.accountTag, this.selectedTransport.serviceName);	
+			if (!forceSendIfOffline && this.selectedTransport.serviceName && 
+				this.selectedTransport.availability == this.Messaging.Availability.OFFLINE && 
+				account && account.availability != this.Messaging.Availability.OFFLINE) {
+					
+				var title = $L("Recipient is offline");
+				var message = new Template($L("#{recipient} is offline.  What would you like to do?")).evaluate({
+					recipient: this.selectedTransport.chatAddress
+				});
+
+				this.controller.showAlertDialog({
+					onChoose: function(choice){
+						if(choice == 'SendAnyway') {
+							this.considerForSend(true);
+						}
+					}.bind(this),
+					title: title,
+					message: message,
+					preventCancel: false,
+					choices: [{
+						label: $L('Send Anyway'),
+						value: 'SendAnyway'
+					},
+					{
+						label: $L('Cancel'),
+						value: 'Cancel'
+					}]
+				});						
+			} else {
+				var segments = this.characterCounter.getSegmentData();
+				if (segments.segmentCount) {
+					for (var x = 0; x < segments.segmentCount; x++) {
+						this.sendMessage(segments.segments[x]);
+					}
+					this.resetTextBox(true);
+					this.revealBottomHack(); // snap to the bottom when the user sends a message
+				} else {
+					Mojo.Log.warn("Segment count is zero or not set."); // This should not happen
+				}
+			}
+		}
+	},
+	
+	sendMessage: function(message){
+		var recipient = this.selectedTransport.chatAddress;
+		
+		// Edge cases:
+		// 1. If the user has a partial number stored in contacts, and we are using the chatAddress to send, the moment that they 
+		//    send or receive on a different transport in the same chat, we will have lost the phone number that was stored in the chat address
+		//    switching back to the phone number that was being used previously will fail to send 
+		// 2. If the transport picker contains a valid short code that happens to be a subset of a different phone number in the transport picker
+		//    Then it is possible for us to send using the chatAddress when we should really use what is in the transport picker
+		if(!this.selectedTransport.serviceName && !this.chatData.serviceName && this.chatData.chatAddress) {
+			var chatNum = MessagingUtils.cleanPhoneNumber(this.chatData.chatAddress);
+			var transportNum = MessagingUtils.cleanPhoneNumber(recipient);
+			if(transportNum.length >= 7 && chatNum.length > transportNum.length) { 
+				var isMatch = true;
+				for(var i=1; i<=transportNum.length && isMatch; i++) {
+					if(transportNum[transportNum.length-i] != chatNum[chatNum.length-i]) {
+						isMatch = false;
+					}
+				}
+				if(isMatch) {
+					recipient = this.chatData.chatAddress;
+				}
+			}
+		}
+		
+		var params = {
+			chatThreadId: this.chatThreadId,
+			recipient: recipient,
+			messageText: message
+		};
+		if(this.selectedTransport.contactPointId)
+			params.contactPointId = this.selectedTransport.contactPointId;
+		if (this.attachment) { // sending an attachment
+			params.attachment = this.attachment;
+			//params.summary = $L('New picture message');
+			params.summary = '';
+		} else { // sending a normal message 
+			if(this.selectedTransport.serviceName)
+				params.serviceName = this.selectedTransport.serviceName;
+		}
+		this.sendMessageHelper(this.controller, params);
+	},
+	
+	addStatusMessageToChat: function(message,transientMsgType) {
+		this.chatHasTransientStatusMessage = true;
+		var params = {
+			chatThreadId: this.chatThreadId,
+			transientMsgType: transientMsgType,
+			messageText: message,
+			recipient: this.selectedTransport.chatAddress,
+			serviceName: this.selectedTransport.serviceName
+		};
+		this.sendMessageHelper(this.controller, params);		
+	},
+	
+	sendMessageHelper: function(controller, params) {
+		MessagingMojoService.sendMessageFromChat(this.controller, params);
+	},
+	
+	resetTextBox: function(resetValue){
+		if (resetValue == true) {
+			this.setTextFieldValue("");
+			this.characterCounter.resetCount();
+		}
+		if (this.messageTextElement.value.length == 0) {
+			this.actionButton.addClassName('empty');
+			this.actionButton.removeClassName('textentry');			
+		}
+		this.controller.get('attachmentContainer').hide();
+		this.controller.get('attachmentImage').src = "";
+		this.attachment = null;
+		this.setCharacterCounterMaxLength();
+		this.handleTextFieldResize();
+	},
+	
+	_fixListScrollPositionWhenTextFieldResize: function(messageTextWidget, listElement, event) {
+		var height = messageTextWidget.offsetHeight + 6;
+		if(messageTextWidget && (!this.textFieldHeight || this.textFieldHeight != height)) {
+			if(!this.textFieldHeight) {
+				this.textFieldHeight = height;
+			}
+			listElement.setStyle({"padding-bottom": height + "px"});
+			this.controller.sceneScroller.mojo.adjustBy(0,(this.textFieldHeight - height));
+			this.textFieldHeight = height;
+		}
+	},
+	
+	_fixListScrollPositionOnLoad: function(messageTextWidget, listElement, setPaddingOnly) {
+		if(!messageTextWidget) {
+			return;
+		}
+		var height = messageTextWidget.offsetHeight + 6;
+		if(!this.textFieldHeight) {
+			this.textFieldHeight = height;
+		}		
+		
+		var doRevealBottom = false;
+		if (!setPaddingOnly && this.getCurrentBottom() < this.MAX_BOTTOM_HEIGHT_FOR_SNAP) {
+			doRevealBottom = true;
+		}
+
+		listElement.setStyle({"padding-bottom": height + "px"});
+		
+		if(doRevealBottom) {
+			this.revealBottomHack();
+		}
+	},
+	
+	attachFilePicker: function(event){
+		var params = {
+			actionType: 'attach',
+			kinds: ['image'], // TODO: integrate other media types
+			defaultKind: 'image',
+			onSelect: this.handleFilePickerSelect.bind(this)
+		};
+		Mojo.FilePicker.pickFile(params,this.controller.stageController);
+	},
+	
+	handleFilePickerSelect: function(file) {
+		this.attachFile(file.fullPath,MessagingUtils.extractfs(file.fullPath,{width:200,height:100,crop:3}));
+	},
+	
+	attachFile: function(imagePath,displayPath){
+		if (imagePath) {
+			if(!displayPath) {
+				displayPath = imagePath;
+			}
+			this.controller.get('attachmentContainer').show();
+			this.actionButton.addClassName('textentry');
+	      	this.actionButton.removeClassName('empty');
+			this.controller.get('attachmentImage').src = displayPath;
+			this.attachment = imagePath;
+			this.setCharacterCounterMaxLength();
+		}
+	},
+	
+	/** 
+	 * Render the invitation UI if we have at least one invitation
+	 * @param callbackIfempty - if there are no invitations then execute
+	 *                          this callback if it has been provided
+	 *                          else render the full chatview UI
+	 */
+	renderInvitationUI: function(callbackIfempty){
+		if (this.invitations.length > 0) {
+			var invitationHash = this.invitations.pop();
+			invitationHash.fromText = new Template($L("From: #{address}")).evaluate({
+				address: invitationHash.address
+			});
+			
+			// hide chatview elements that we don't want to see &
+			// show the invitations UI
+			this.transportPicker.hide();
+			var footerInvitationContent = Mojo.View.render({
+				object: invitationHash,
+				template: "chatview/invitation-footer"
+			});
+			this.controller.get('footerInvitation').update(footerInvitationContent);
+			this.controller.get('footerInvitation').show();
+			this.controller.get('footer').hide(); // hide the chatview footer
+			// observe the accept/ignore buttons
+			this.acceptInvitation = this.controller.get('acceptInvitation');
+			this.rejectInvitation = this.controller.get('rejectInvitation');
+			/* 
+			//This needs to be cleaned up when we start supporting invitations
+			this.acceptInvitation.observe(Mojo.Event.tap, this.handleInvitationAccept.bind(this).curry(invitationHash, this.handleAcceptInvitation.bind(this)));
+			this.rejectInvitation.observe(Mojo.Event.tap, this.handleRejectInvitation.bind(this).curry(invitationHash));
+			*/
+			return;
+		}
+		
+		this.controller.get('footer').show();
+		this.controller.get('footerInvitation').hide();
+		this.transportPicker.show();
+		
+		// Do this after hiding/showing elements in case the view has been
+		// popped in the callbackIfempty()
+		if (callbackIfempty) {
+			callbackIfempty();
+		}
+	},
+	
+	handleInvitationAccept: function(invitationHash, callback, event){
+    var listItems = [{label:$L('Add buddy to...'), command:"", disabled:true}, {label:$L('Groups')}];
+		// Retrieve groups that this invitation can be accepted into
+		MessagingMojoService.getGroupsForInvitation(this.controller, function(result){
+			result.list.each(function(group){
+				listItems.push({
+					label: group.groupName,
+					command: group.id
+				});
+			});
+			
+			this.controller.popupSubmenu({
+				onChoose: callback.bind(this).curry(invitationHash),
+				placeNear: event.target,
+				items: listItems
+			});
+		}.bind(this));
+	},
+	
+	handleAcceptInvitation: function(invitationHash, groupId){
+		MessagingMojoService.acceptBuddy(this.controller, this.chatThreadId, invitationHash.id, invitationHash.address, groupId, function(result){
+			if (result.personId) {
+				this.personId = result.personId;
+				// if we have more invitations for this chat, render another invitation footer
+				this.renderInvitationUI(function(){
+					var params = {
+						serviceName: this.selectedTransport.serviceName,
+						chatAddress: this.selectedTransport.chatAddress,
+						availability: this.selectedTransport.availability
+					}
+					this.renderTransportPicker(params);
+				}.bind(this));
+			}
+		}.bind(this));
+	},
+	
+	addTextToClipboard: function(text){
+		if (text) {
+			// Temporarily unassign the text element to prevent it from automatically
+			// refocusing on blur, then do the copy-to-clipboard.
+			var temp = this.messageTextElement;
+			this.messageTextElement = undefined;
+			// Note html tags are stripped from the text since the clipboard only supports plain text
+			this.controller.stageController.setClipboard(text.stripTags(), false);
+			this.messageTextElement = temp;
+			this.messageTextElement.focus();
+		}
+	},
+	
+	copyConversationToClipboard: function() {
+		var range = this.chatListWidget.mojo.getLoadedItemRange();
+		var list = this.chatListWidget.mojo.getItems(range.offset, range.limit);
+		if (list.length > 0) {
+			var text = list.pluck('messageText').join("\n\n");
+			this.addTextToClipboard(text);
+		}
+	},
+	
+	blockUsername: function() {
+		var onChooseHandler = function(value) {
+			if (value === 'block') {
+				// If this chat was blocked, pop out to the listview
+				var onSuccessFunc = this.popAndRevealListView.bind(this);
+				MessagingMojoService.blockBuddy(this.controller, this.chatThreadId, true, onSuccessFunc);
+			}
+		}.bind(this);
+
+		this.controller.showAlertDialog({
+			onChoose: onChooseHandler,
+			title: $L('Block this person'),
+			message: $L("Are you sure you want to block this person?"),
+			preventCancel: false,
+			choices: [
+				{label: $L('Block'), value: 'block', type: 'negative'},
+				{label: $L('Cancel'), value: 'cancel', type: 'secondary'}
+			]
+		});
+	},
+	
+	handleRejectInvitation: function(invitationHash, event){
+		MessagingMojoService.rejectBuddy(this.controller, this.chatThreadId, invitationHash.id, invitationHash.address, function(result){
+			this.renderInvitationUI(function(){
+				if (result.chatIsEmpty) { // if the chat was deleted, pop out to the listview
+					this.popAndRevealListView();
+				}
+			}.bind(this));
+		}.bind(this));
+	},
+	
+	updateBlockUsernameMenu: function() {
+		// personId is only set if the chat is with someone in the user's contacts
+		var hideBlockMenu = (this.chatData == undefined || this.chatData.type !== "IM" || this.personId != undefined);
+		var blockItemIndex = this.appMenuModel.items.indexOf(this.appMenuBlockUsernameItem);
+		if (hideBlockMenu) {
+			// -1 means it isn't in the list so it doesn't need to be removed
+			if (blockItemIndex !== -1) {
+				this.appMenuModel.items.splice(blockItemIndex, 1);
+				this.controller.modelChanged(this.appMenuModel);
+			}
+		} else {
+			if (blockItemIndex === -1) {
+				this.appMenuModel.items.splice(this.appMenuModel.items.length-1, 0, this.appMenuBlockUsernameItem);
+				this.controller.modelChanged(this.appMenuModel);
+			}
+		}
+	},
+	
+	showAttachButton: function(){
+		this.controller.get('AttachButton').show();
+		this.appMenuAddPictureItem.disabled = false;
+		this.controller.modelChanged(this.appMenuAddPictureItem);
+	},
+	
+	hideAttachButton: function(){
+		this.controller.get('AttachButton').hide();
+		this.appMenuAddPictureItem.disabled = true;
+		this.controller.modelChanged(this.appMenuAddPictureItem);
+	},
+	
+	getAudioElementCacheInstance: function() {
+		if(!this.audioElementCache) {
+			this.audioElementCache = function() {
+				var elemHash = {};
+				var elemArr = [];
+				var maxSize = 10;
+				
+				return {
+					get: function(id) {
+						if(elemHash[id])
+							return elemHash[id];
+					},
+					add: function(id,element) {				
+						elemHash[id] = element;
+						elemArr.push(id);
+						
+						// remove the oldest element
+						if(elemArr.length == maxSize) {
+							delete elemHash[elemArr[0]];
+							elemArr.splice(0,1);
+						}				
+					},
+					hasElement: function(id) {
+						if(id && elemHash[id])
+							return true;
+						return false;
+					}
+				}
+			}();
+		}	
+		return this.audioElementCache;	
+	},
+	
+	revealBottomHack: function() {
+		// do this twice because calling revealBottom() once sometimes only gets you close to the bottom
+		this.controller.sceneScroller.mojo.revealBottom();
+		this.controller.sceneScroller.mojo.revealBottom();
+	}
+});
\ No newline at end of file
diff --git a/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js b/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js
index 9715c78..bde693c 100644
--- a/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js
+++ b/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js
@@ -147,6 +147,11 @@ var ComposeAssistant = Class.create({
 			segmentCountContainer: this.controller.get('segmentCounterContainer'),
 			segmentCountElement: this.controller.get('segmentCounter'),
 			setTextFieldValueFn: this.setTextFieldValue.bind(this)
+		},
+		charCounter: {
+			charCountContainer: this.controller.get('charCounterContainer'),
+			charCountElement: this.controller.get('charCounter'),
+			setTextFieldValueFn: this.setTextFieldValue.bind(this)
 		}
 	};
 
diff --git a/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js.orig b/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js.orig
new file mode 100644
index 0000000..9715c78
--- /dev/null
+++ b/usr/palm/applications/com.palm.app.messaging/app/controllers/compose-assistant.js.orig
@@ -0,0 +1,565 @@
+/* Copyright 2009 Palm, Inc.  All rights reserved. */
+
+var ComposeAssistant = Class.create({
+	initialize : function(params) {
+		this.appController = Mojo.Controller.getAppController();
+		this.Messaging = this.appController.Messaging;
+		this.attachment;
+		this.messageTextElement;
+		this.prePopulatedRecipients = [];
+		this.sendMessageCount = 0;	// keep a count of how many times we call send so we know when the last callback is hit
+		this.sentRecipients = [];
+		
+		var listviewSceneAssistant = this.Messaging.listviewSceneAssistant;
+		if (listviewSceneAssistant) {
+			this.toggleDebugMenu = listviewSceneAssistant.toggleDebugMenu.bind(listviewSceneAssistant,true);
+		}
+
+		this.appMenuAddPictureItem = {label: $L('Add picture...'), command:'addPicture', enabled:true};
+
+		this.appMenuAttrs = {omitDefaultItems: true};	
+		this.appMenuModel = { visible:true, label: $L('Chat view menu'), items: [Mojo.Menu.editItem,this.appMenuAddPictureItem,Mojo.Menu.helpItem]};   
+	 
+		if(params && params.focusWindow)
+			this.focusWindow = true;
+		else
+			this.focusWindow = false;
+
+		if (params) {
+			
+			if (params.launchedAsForward){
+				this.launchedAsForward = true;
+			}
+			
+			this.passedAttachment = params.attachment || '';
+			this.messageText = params.messageText || '';
+			
+			// DEPRECATED
+			if(params.composeAddress) {
+				this.prePopulatedRecipients.push({
+					value: params.composeAddress,
+					contactDisplay: params.composeAddress,
+					type: (params.serviceName ? 'im' : 'phone'),
+					serviceName: params.serviceName || ''
+				});
+			}
+			
+			/*
+			 *	composeRecipients expects the following:
+			 *  [
+			 *  	{
+			 *  		"address": <phone number or IM>,
+			 *  		"serviceName": <serviceName or domain> // only required for IM addresses
+			 *  	}, ...
+			 *  ]
+			 */
+			if(params.composeRecipients && params.composeRecipients.length) {
+				for (var i = 0; i < params.composeRecipients.length; i++) {
+					var recipient = params.composeRecipients[i];
+					if (recipient.address) {
+						this.prePopulatedRecipients.push({
+							value: recipient.address,
+							contactDisplay: recipient.address,
+							type: (recipient.serviceName ? 'im' : 'phone'),
+							serviceName: recipient.serviceName || ''
+						});
+					}
+				}
+			}
+		}
+		
+		this.considerForSend = this.considerForSend.bind(this);
+		this.attachFilePicker = this.attachFilePicker.bind(this);
+		this.handleTextAreaChange = this.handleTextAreaChange.bind(this);
+		this.handleTextAreaKeyUp = this.handleTextAreaKeyUp.bind(this);
+		this.handleCancelAttachment = this.resetTextBox.bind(this,false);		
+		this.handleRecipientsChanged = this.handleRecipientsChanged.bind(this);
+
+		this.monkeyPatchAddressingWidget();		
+	},
+
+  setup: function() {
+    this.controller.setupWidget(Mojo.Menu.appMenu, this.appMenuAttrs, this.appMenuModel);
+
+	this.searchList = {
+		"property": "to$A",
+		"includeEmails": false,
+		"includePhones": true,
+		"includeIMs": true,
+		"includeShortCode": true,
+		"hintText": $L('Enter name or number...'),
+		"labelText": $L("To:"),
+		"focus": true,
+		"recipients": this.prePopulatedRecipients,
+		"determineTypeFunction": function(str){
+			if (str.indexOf("@") > -1) {
+				return "email";
+			}
+			return "phone";
+		}
+	};
+
+    this.controller.setupWidget('searchList', null, this.searchList);   
+
+	var messageTextWidgetAttributes = {
+	    textFieldName: "messageTextElement",
+	    hintText: $L('Enter message here...'),
+	    multiline: true,
+	    focus: false,
+	    enterSubmits: true,
+		requiresEnterKey: true,
+	    modelProperty: "value",
+		changeOnKeyPress: true
+	};
+	this.messageTextWidgetModel = {};
+  
+    this.controller.setupWidget('messageTextWidget', messageTextWidgetAttributes, this.messageTextWidgetModel);
+	
+    this.controller.listen('SendButton',Mojo.Event.tap, this.considerForSend);
+    this.controller.listen('AttachButton',Mojo.Event.tap, this.attachFilePicker);
+    this.controller.listen('cancelAttachment',Mojo.Event.tap, this.handleCancelAttachment);
+  },
+
+  ready: function() {
+	this.actionButton = this.controller.get('ActionButton');
+	this.addressingForm = this.controller.get('addressingForm');
+	this.messageTextWidget = this.controller.get('messageTextWidget');
+	this.messageTextElement  = this.messageTextWidget.querySelector('[name=messageTextElement]');
+	this.addressingWidget = this.controller.get('searchList');
+	this.addressingWidgetSpacer = this.controller.get('addressingWidgetSpacer');
+	
+	this.addressingWidgetSpacer.setStyle({
+		'height': (Mojo.Environment.DeviceInfo.maximumCardHeight - this.addressingWidget.offsetHeight) + "px"
+	});
+	
+	
+	this.messageTextElement.observe('keyup', this.handleTextAreaKeyUp);
+	this.messageTextWidget.observe(Mojo.Event.propertyChange, this.handleTextAreaChange);
+	
+    // Observe add/delete to the addressing widget
+    var that = this;
+    [Mojo.Event.addressingRecipientAdded,Mojo.Event.addressingRecipientDeleted].each(function(event) {
+      that.controller.listen('searchList',event,that.handleRecipientsChanged);
+    });	
+	
+	var charCounterParams = {
+		segmentCounter: {
+			segmentCountContainer: this.controller.get('segmentCounterContainer'),
+			segmentCountElement: this.controller.get('segmentCounter'),
+			setTextFieldValueFn: this.setTextFieldValue.bind(this)
+		}
+	};
+
+	this.characterCounter = new CharacterCounter(this.controller,this.Messaging.messagingPrefs.platformType,this.messageTextElement,charCounterParams);
+	this.characterCounter.setSizeParams();
+	
+	if (this.messageText) {
+		this.setTextFieldValue(this.messageText);
+	}
+	
+	if (this.passedAttachment) {
+		this.attachFile(this.passedAttachment);
+	}
+  },
+  
+  considerForSend: function(){
+	var message = this.messageTextElement.value.strip();
+	if ((!this.attachment && message.length > 0) || this.attachment) {
+		if (this.isDebugCommand(message)) {
+			return;
+		}
+
+		// if the current message is longer than the max size, alert the user and block the send action
+		if (!this.characterCounter.isValidLength()) {
+			this.controller.showAlertDialog({
+				onChoose: function(){
+				},
+				title: $L("Message length error"),
+				message: $L("The message that you have entered is larger than the allowed size."),
+				preventCancel: false,
+				choices: [{
+					label: $L('Ok'),
+					value: 'Close'
+				}]
+			});
+			return;
+		}
+		var recipientsArray = Mojo.View.serializeMojo(this.addressingForm, true).to$A;
+
+		if ($A(recipientsArray).length > 0) {
+			var phoneRecipients = [];
+			var imRecipients = [];
+			// separate the different types of recipients
+			for(var x=0; x<recipientsArray.length; x++) {
+				var recipient = recipientsArray[x];
+				if (recipient.serviceName) {
+					// make sure that the serviceName is supported
+					var isSupported = this.Messaging.isIMAccountTypeSupported(recipient.serviceName);
+					if(!isSupported.returnValue) {
+						var errorMessage = '';
+						if(!isSupported.isSupportedType) {
+							errorMessage = $L("You are attempting to send to an IM type that is not supported.  Please choose a different address.");
+						} else if(!isSupported.hasAccount) {
+							errorMessage = $L("You are attempting to send to an IM type for which you do not have an account to send from.");
+						}
+						
+						this.controller.showAlertDialog({
+							onChoose: function(){},
+							title: $L("Unable to send"),
+							message: errorMessage,
+							preventCancel: false,
+							choices: [{
+								label: $L('Ok'),
+								value: 'Close'
+							}]
+						});
+						return;
+					}
+					imRecipients.push(recipient);
+				} else {
+					phoneRecipients.push(recipient);
+				}
+			}
+
+			// send to phone recipients
+			if (phoneRecipients.length > 0) {
+				var segmentData = this.characterCounter.getSegmentData();
+				if (segmentData.segmentCount) {
+					for (var x = 0; x < segmentData.segmentCount; x++) {
+						this.sendMessage(phoneRecipients, segmentData.segments[x]);
+						this.sendMessageCount++;
+					}
+				}
+			}
+
+			// send to IM recipients, don't segment the data for IM
+			if(imRecipients.length > 0) {
+				this.sendMessage(imRecipients, message);
+				this.sendMessageCount++;
+			}
+
+			this.sentRecipients = recipientsArray;
+			this.resetTextBox(true);
+		} else {
+			this.controller.showAlertDialog({
+				onChoose: function(){
+				},
+				title: $L("Please choose a recipient."),
+				choices: [{
+					label: $L('Done'),
+					value: 'Ok'
+				}]
+			});
+		}
+	}     
+  },
+  
+	sendMessage: function(recipientsArray,message) {
+		if(!this.handleSentMessageResponse) {
+			this.handleSentMessageResponse = this._handleSentMessageResponse.bind(this);
+		}
+		var params = {
+			recipientJSONArray: recipientsArray,
+     		messageText: message,
+      		onSuccess: this.handleSentMessageResponse
+		};
+		if (this.attachment) { // sending an attachment
+			params.attachment = this.attachment;
+			//params.summary = $L('New picture message');
+			params.summary = '';
+		}
+		this.actionButton.addClassName('invisible');
+		MessagingMojoService.sendMessageFromCompose(this.controller, params); 
+	},
+  
+  _handleSentMessageResponse: function (result) {
+  	if (--this.sendMessageCount == 0) {
+		if(this.sentRecipients.length == 1) {
+			this.controller.stageController.swapScene('chatview', result.chatThreadId);
+		} else {
+			// if we have multiple recipients, just pop this scene + set the current view to be the history view
+			this.Messaging.setListViewVisible(this.Messaging.Views.HISTORY);
+			if(!MessagingUtils.sceneExistsInStack(this.controller.stageController,'listview')) {
+				this.appController.assistant.getListChunk(this.controller,this.handleListChunkOnPop.bind(this));
+			} else {
+				this.controller.stageController.popScenesTo('listview');
+			}			
+		}
+		this.setTextFieldValue("");
+	}
+  },
+  
+	isDebugCommand: function(message) {
+		if(message == "--palmDebug" && !Mojo.View.serializeMojo(this.addressingForm, true).to$A) {
+			this.toggleDebugMenu();
+			this.controller.stageController.popScene();
+			this.controller.stageController.pushScene('debug');
+			return true;
+		}
+		return false;
+	},
+
+	setTextFieldValue: function(value) {
+		if(value != undefined) {
+			this.messageTextWidgetModel.value = value;
+			this.controller.modelChanged(this.messageTextWidgetModel);
+			// make sure the right action button is showing if there is any text in the textbox
+			this.handleTextAreaChange();			
+		} 
+	},
+
+	handleTextAreaKeyUp: function(event) {
+		if (event && Mojo.Char.isEnterKey(event.keyCode)) {
+			this.considerForSend();
+			Event.stop(event);
+		}		
+	},
+
+	handleTextAreaChange: function() {
+		if (this.messageTextElement && this.messageTextElement.value == '') {
+			this.actionButton.removeClassName('textentry');
+			this.actionButton.addClassName('empty');
+		} else {
+			this.actionButton.addClassName('textentry');
+			this.actionButton.removeClassName('empty');
+		}
+		
+		this.characterCounter.deferredResetCount();	
+	},
+
+  attachFilePicker: function(event) {   
+    var params = {
+		actionType: 'attach',
+        kinds: ['image'], // TODO: integrate other media types
+        defaultKind: 'image',
+        onSelect: this.handleFilePickerSelect.bind(this)
+    };
+    Mojo.FilePicker.pickFile(params,this.controller.stageController);  
+  },
+  
+	handleFilePickerSelect: function(file) {
+		this.attachFile(file.fullPath,MessagingUtils.extractfs(file.fullPath,{width:200,height:100,crop:3}));
+	},  
+  
+	attachFile: function(imagePath,displayPath) {
+		if (imagePath) {
+			if (!displayPath) {
+				// Check for supported attachment type.
+				// This isn't great but have nothing else to go on, like a mimetype
+				if (imagePath.endsWith('.vcf')) {
+					displayPath = Mojo.appPath + "images/compose-attachment-vcard.png";
+				} else {
+					displayPath = imagePath;
+				}
+			}
+			this.controller.get('attachmentContainer').show();
+			this.actionButton.addClassName('textentry');
+			this.actionButton.removeClassName('empty');
+			this.controller.get('attachmentImage').src = displayPath;
+			this.attachment = imagePath;
+			this.searchList.includeIMs = false;
+			this.controller.modelChanged(this.searchList);
+			this.characterCounter.setSizeParams();
+		}
+	},
+
+  resetTextBox: function(resetValue){
+    if (resetValue == true) {
+	  this.setTextFieldValue("")
+    }
+    if (this.messageTextElement.value.length == 0) {
+		this.actionButton.removeClassName('textentry');
+		this.actionButton.addClassName('empty');
+		this.characterCounter.resetCount();
+	}
+    this.controller.get('attachmentContainer').hide();
+    this.controller.get('attachmentImage').src = "";   
+    this.attachment = null;  
+    this.searchList.includeIMs = true;  
+    this.controller.modelChanged(this.searchList);  
+	this.setCharacterCounterMaxLength();  
+  },
+
+  handleRecipientsChanged: function() {
+	var recipientsArray = Mojo.View.serializeMojo(this.addressingForm, true).to$A;
+    // iterate through recipients and determine if we have an IM contact
+    var hasIM = false;
+	if (recipientsArray) { 
+		for(var i=0; i<recipientsArray.length && !hasIM; i++) {
+			if (recipientsArray[i].serviceName) {
+				hasIM = true;
+			}
+		}
+	}
+    // Hide the attach button if there is an IM contact
+    if(hasIM == true) {         
+      this.hideAttachButton();
+    } else {                  
+      this.showAttachButton();
+    }
+	this.setCharacterCounterMaxLength();
+  },
+  
+  cleanup: function() {
+    var that = this;
+	
+    this.controller.stopListening('SendButton',Mojo.Event.tap, this.considerForSend);
+    this.controller.stopListening('AttachButton',Mojo.Event.tap, this.attachFilePicker);
+    this.controller.stopListening('cancelAttachment',Mojo.Event.tap, this.handleCancelAttachment);	
+	
+    [Mojo.Event.addressingRecipientAdded,Mojo.Event.addressingRecipientDeleted].each(function(event) {
+      that.controller.stopListening('searchList',event,that.handleRecipientsChanged);
+    });
+	
+	this.messageTextElement.stopObserving('keyup', this.handleTextAreaKeyUp);
+	this.messageTextWidget.stopObserving(Mojo.Event.propertyChange, this.handleTextAreaChange);
+	
+	this.characterCounter.destroy();
+  },
+
+  activate: function() {
+	if(this.focusWindow) {
+		this.focusWindow = false;
+		this.controller.stageController.activate();
+	}  	
+  },
+  
+  deactivate: function() {
+  },
+
+	handleCommand: function(event) {
+		if(event.type == Mojo.Event.command) {
+			if(event.command == 'addPicture') {
+				this.attachFilePicker();
+				event.stop();
+			} 
+		} else if(event.type == Mojo.Event.back) {
+			if(!this.launchedAsForward){
+				event.stop();
+				if(!MessagingUtils.sceneExistsInStack(this.controller.stageController,'listview')) {
+					this.appController.assistant.getListChunk(this.controller,this.handleListChunkOnPop.bind(this));
+				} else {
+					this.controller.stageController.popScenesTo('listview');
+				}
+				return;
+			}
+		}
+	},
+	
+	handleListChunkOnPop: function(forceListView,result) {
+		this.controller.stageController.popScenesTo('listview');
+		this.controller.stageController.pushScene('listview',{forceListView:forceListView, listDataChunk:result});
+	},
+  
+  showAttachButton: function() {
+    this.controller.get('AttachButton').show();
+    this.appMenuAddPictureItem.disabled = false;
+    this.controller.modelChanged(this.appMenuAddPictureItem);      
+  },
+  
+  hideAttachButton: function() {
+    this.controller.get('AttachButton').hide();
+    this.appMenuAddPictureItem.disabled = true;
+    this.controller.modelChanged(this.appMenuAddPictureItem);      
+  },
+  
+	setCharacterCounterMaxLength: function() {
+		var recipientsArray = Mojo.View.serializeMojo(this.addressingForm, true).to$A;
+		var hasPhoneNumber = false;
+		var hasEmail = false;
+		var longestEmailAddress = "";
+
+		if(recipientsArray) {
+			for(var i=0; i<recipientsArray.length; i++) {
+				var recipient = recipientsArray[i];
+				
+				if(!recipient.serviceName) {
+					if(recipient.value.indexOf("@") > -1) {
+						hasEmail = true;
+						if(recipient.value.length > longestEmailAddress.length) {
+							longestEmailAddress = recipient.value;
+						}						
+					} else {
+						hasPhoneNumber = true;
+					}
+				}
+			}
+		}
+		var params = {
+			maxPartLength: 1000,
+			maxParts: 1,
+			headerSize: 0,
+			encodings:""
+		};
+		if (!this.attachment) {
+			if (hasPhoneNumber && !hasEmail) { // SMS
+				params.maxPartLength = this.Messaging.carrierSettings.smsMessageSizeLimit;
+				params.maxParts = this.Messaging.carrierSettings.smsMaxPartsPerMessage;
+				params.headerSize = this.Messaging.carrierSettings.smsHeaderSizeLimit;
+			} else if (hasEmail) { // SMS to email
+				params.maxPartLength = (this.Messaging.carrierSettings.smsMessageSizeLimit - (longestEmailAddress.length + 1));
+				params.maxParts = 1;
+				params.headerSize = 0;
+			}
+			
+			params.encodings = this.Messaging.carrierSettings.smsEncoding;
+		}
+		
+		this.characterCounter.setSizeParams(params);	
+	},
+	
+	/*******
+	 * Monkey patch the addressing widget if the carrier requires limiting recipients
+	 *******/
+	monkeyPatchAddressingWidget: function() {
+		if (this.Messaging.carrierSettings && this.Messaging.carrierSettings.smsMaxRecipients > 0) {
+			Mojo.Log.warn("carrierSettings.smsMaxRecipients=%i, monkey patching addRecipients", this.Messaging.carrierSettings.smsMaxRecipients);
+
+			Mojo.Widget.AddressingWidget.prototype.maxRecipients = this.Messaging.carrierSettings.smsMaxRecipients;
+			Mojo.Widget.AddressingWidget.prototype.addRecipient = function(recip) {
+				try {
+					if (this.totalRecips >= this.maxRecipients) {
+						if (this.showingMaxRecipientsDlg !== true) {
+							this.showingMaxRecipientsDlg = true;
+							var messageText = $L("There is a maximum of #{maxRecipients} recipients per message.").interpolate(this);
+							this.controller.scene.showAlertDialog({
+								onChoose: function() { this.showingMaxRecipientsDlg = false}.bind(this),
+								title: $L("Unable to add recipient"),
+								message: messageText,
+								choices: [{ label: $L('Dismiss'), value: 'dismiss' }]
+							});
+						}
+						return;
+					}
+				} catch (e) {
+					Mojo.Log.logException(e, "Messaging.addRecipient")
+				}
+				var content, element;
+				var recipDiv;
+				
+			  	//do 2 things when a user adds a recipient:
+			  	//1) create the "pretty view" based on the recipient.html template
+			  	//2) create the real info view based on the recipient-info.html template
+				if (recip.personId) {
+					recip.alreadyValidated = true;
+				}
+			  	recip.prefix = this.prefix;
+			  	recip.identifier = Mojo.View.makeUniqueId();	
+				
+			  	content = Mojo.View.render({object: recip, template: Mojo.Widget.getSystemTemplatePath("/addr-widget/recipient")});
+			  	element = this.recipientArea.insert({bottom: content}); //add these between the input box and "to"	
+			  	this.resetTextFieldValue();
+				recipDiv = this.controller.get(recip.identifier);
+				
+				//set json for this field
+				this._setJsonRecip(recip, recipDiv);
+				
+			  	if (!recip.alreadyValidated && this._validateRecipient(recip, recipDiv)) {
+			  	  this._reverseLookup(recip, recipDiv);
+			  	}
+				Mojo.Event.send(this.controller.element, Mojo.Event.addressingRecipientAdded);
+				this.totalRecips++;
+			}
+		}
+	}
+});
diff --git a/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js b/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js
index a5efef9..24c54ab 100644
--- a/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js
+++ b/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js
@@ -54,6 +54,10 @@ var CharacterCounter = Class.create({
 				containerElement: null,
 				valueElement: null
 			};
+			var charCounterUI = {
+				containerElement: null,
+				valueElement: null
+			};
 			
 						
 			// TODO: eventually we might want to implement some cleverness that counts
@@ -297,6 +301,20 @@ var CharacterCounter = Class.create({
 				}
 			};
 			
+			var setCurrentCharCount = function(newCharCount) {
+				if(charCounterUI.valueElement)
+					charCounterUI.valueElement.update(newCharCount);
+				if(charCounterUI.containerElement) {
+					if (newCharCount == 0) {
+						if (charCounterUI.containerElement.visible())
+							charCounterUI.containerElement.hide();
+					} else {
+						if (!charCounterUI.containerElement.visible())
+							charCounterUI.containerElement.show();
+					}
+				}
+			};
+			
 			return {
 				
 				init: function(controller,platform,textElement,params) {
@@ -404,7 +422,13 @@ var CharacterCounter = Class.create({
 								setTextFieldValueFn = params.segmentCounter.setTextFieldValueFn;
 							}						
 						}
-
+						if(params.charCounter) {
+							charCounterUI.containerElement = params.charCounter.charCountContainer;
+							charCounterUI.valueElement = params.charCounter.charCountElement;
+							if(params.charCounter.setTextFieldValueFn) {
+								setTextFieldValueFn = params.charCounter.setTextFieldValueFn;
+							}						
+						}
 					}					
 				},
 				
@@ -472,6 +496,7 @@ var CharacterCounter = Class.create({
 					
 					var messageData = parseMessage(rawCharacterData.message,rawCharacterData.count,true);
 					adjustedCharacterCount = messageData.adjustedCharacterCount;
+					setCurrentCharCount(rawCharacterData.count);
 					if (adjustedMaxLen > 0)
 						setOverLimit(messageData.isOverLimit);
 					setCurrentSegmentCount(messageData.segmentCount);				
diff --git a/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js.orig b/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js.orig
new file mode 100644
index 0000000..a5efef9
--- /dev/null
+++ b/usr/palm/applications/com.palm.app.messaging/app/utilities/CharacterCounter.js.orig
@@ -0,0 +1,501 @@
+/* Copyright 2009 Palm, Inc.  All rights reserved. */
+
+var CharacterCounter = Class.create({	
+	initialize: function(controller,platformType,textAreaElement,params) {
+		var characterCounter = function() {
+			var platformConst = {
+				'gsm': {
+					ADD_MESSAGE_HEADERS: false,
+					RETURN_ONE_SEGMENT_ONLY: true,  // segmentation will happen at the TIL level for GSM
+					BREAK_ON_WORD_BOUNDARIES: false
+				},
+				'cdma': {
+					ADD_MESSAGE_HEADERS: true,
+					RETURN_ONE_SEGMENT_ONLY: false,	// segmentation happens in the UI for CDMA
+					BREAK_ON_WORD_BOUNDARIES: true		
+				}
+			}
+			
+			var platformData;
+			
+			var sceneController;
+			var platformType;
+			var textAreaElement;			// text area to count/limit
+			var setTextFieldValueFn;
+			
+			var encoding = 0;
+			
+			var _maxLength = 0;
+			var _oneSegmentMaxSize = 160;
+			var _multipleSegmentMaxSize = 151;  // default will work for gsm/cdma
+			var _maxparts = 1;
+			
+			var adjustedMaxLen = _maxLength;
+			var adjustedOneSegmentMaxLen = _oneSegmentMaxSize;
+			var adjustedMultipleSegmentMaxSize = _multipleSegmentMaxSize;
+			
+			var recheckAllTextForNonGsm = true;
+			
+			/*
+			 * supporting 2 byte chars here always means GSM7 or UCS2
+			 * CDMA case is always 1. 
+			 */
+			var support2ByteChars = true;
+
+			var isOverLimit = false;		// is the current adjustedCharacterCount > maxLength
+			var adjustedCharacterCount = 0; // includes holes created by word bounded segmentation
+			var currentSegmentCount = 0;
+			var textSavedBeforePaste;		// used to revert a paste event if the max length is exceeded
+			var selectionStartSavedBeforePaste = 0;
+			var selectionEndSavedBeforePaste = 0;
+			var multiMessageHeaderTemplate = new Template($L("(#{currentSegmentIndex} of #{lastSegmentIndex}) "));
+
+			var segmentCounterUI = {
+				containerElement: null,
+				valueElement: null
+			};
+			
+						
+			// TODO: eventually we might want to implement some cleverness that counts
+			// bytes so we can accurately limit text that includes UTF-8 characters.
+			// Currently this only works for ASCII text
+			var getRawCharacterData = function() {
+				// DO NOT strip whitespace from the end of the message.  Doing this can cause
+				// problems when approaching the max size limit.  If enough spaces are be added to 
+				// get past the limit, then a single character can be entered to exceed the limit.
+				
+				var message = textAreaElement.value;
+				
+				return {count:message.length, message:message};
+			};
+
+			var setOverLimit = function(isOver) {
+				if (isOver) {
+					isOverLimit = true;
+						
+					if(segmentCounterUI.valueElement)
+						segmentCounterUI.valueElement.className = 'overLimit';
+	
+				} else {
+					isOverLimit = false;
+						
+					if(segmentCounterUI.valueElement)
+						segmentCounterUI.valueElement.className = '';					
+				}				
+			};
+			
+			/*
+			 * TODO revalidate this array
+			 * this array is a capture of all of the high byte ascii characters integrated into GSM 7
+			 */
+			var extraGsm7Chars = [161, 163, 167, 191, 196, 197, 198, 199, 201, 209, 214, 220, 223, 224, 228, 229, 230, 232, 233, 236, 241, 242, 246, 248, 249, 252];
+			
+			var isGsm7Char = function(charCode){
+				/*
+				 * TODO for now just use under/over 127, fix this later
+				 */
+				if (charCode > 127){
+					var found = false;
+					var i;
+					for (i =0; i < extraGsm7Chars.length; i++){
+						if (charCode == extraGsm7Chars[i]){
+							found = true;
+							break;
+						}
+					}
+					if (found === false){
+						Mojo.Log.info("found non GSM 7 Char " + charCode);
+						return false;
+					}
+				}
+				
+				/*
+				 * TODO remove this
+				 * hack in u just so we can test on sim
+				 */
+				//if (charCode === 117){
+					//return false;
+				//}
+				
+				return true;
+			}
+			
+			/**
+			 * This method segments the message text so multiple SMS messages
+			 * can be sent from whatever the user entered
+			 * 
+			 * @param {Object} message - raw message to parse - no spaces should have
+			 * 							 been stripped from the beginning/end of the message
+			 * @param {Object} currLen - length of the message
+			 * @param {Object} isCountOnly - return the count only, not the actual segmented data
+			 */
+			var parseMessage = function(message,currLen,isCountOnly) {
+				var result = {
+					adjustedCharacterCount: 0,
+					segmentCount: 0,
+					segments: [],
+					isOverLimit: false
+				};
+				
+				/*
+				 * something has triggered a complete recheck of the text
+				 */
+				Mojo.Log.info("supporting 2 bye chars " + support2ByteChars);
+				if ( (support2ByteChars === true) && (recheckAllTextForNonGsm === true) ){
+					Mojo.Log.info("rechecking all text");
+					/*
+					 * clear the recheck, we are doing it
+					 */
+					recheckAllTextForNonGsm = false;
+					var found = false;
+		
+					/*
+					 * loop through and look for non GSM 7
+					 */
+					Mojo.Log.info("message length " + message.length);
+					var i;
+					for (i=0; i < message.length; i+=1){
+						Mojo.Log.info("charCode " + message.charCodeAt(i));
+						if (false === isGsm7Char(message.charCodeAt(i))){
+							Mojo.Log.info("found non GSM 7, assume 2 bytes per char");
+							found = true;
+							break;
+						}
+					}
+					
+					if (found){
+						Mojo.Log.info("setting sizes to UCS2 defaults")
+						/*
+						 * lengths in are really character lengths, and in the case of UCS2
+						 * the values in are relavent to GSM7 which as a packed 7 bit encoding
+						 * goofies up the count when converting to UCS2. In all practicality
+						 * GSM7/UCS2 is always going to boil down to
+						 * GSM7 : oneSeg = 160, multipleSegMaxSize = 153, maxLen = 153 * _maxparts
+						 * UCS2 : oneSeg = 70, multipleSegMaxSize = 67, maxLen = 67 * _maxparts
+						 */
+						//adjustedMaxLen = Math.floor(_maxLength/2);
+						//adjustedMultipleSegmentMaxSize = Math.floor(_multipleSegmentMaxSize/2);
+						//adjustedOneSegmentMaxLen = Math.floor(_oneSegmentMaxSize/2);
+						adjustedMaxLen = 67 * _maxparts;
+						adjustedMultipleSegmentMaxSize = 67;
+						adjustedOneSegmentMaxLen = 70;						
+					}else{
+						Mojo.Log.info("no doubles found, setting to 1");
+						adjustedMaxLen = _maxLength;
+						adjustedMultipleSegmentMaxSize = _multipleSegmentMaxSize;
+						adjustedOneSegmentMaxLen = _oneSegmentMaxSize;
+					}
+					
+				}
+
+				/*
+				 * TODO to make things more accurate in the in the GSM7 case I need to run
+				 * through looking for the 10 special double byte GSM 7 chars and factor those
+				 * in here too.
+				 */
+				
+				if (adjustedMaxLen > 0 && currLen > adjustedOneSegmentMaxLen) { // more than 1 segment
+					var beginning = 0;
+					var end = 0;
+					while (end < currLen && result.adjustedCharacterCount < adjustedMaxLen) {
+						beginning = end;
+						// skip any spaces that may already be at the beginning
+						// of this segment
+						if (message.charAt(beginning) == ' ') {
+							var foundNonSpace = false;
+							beginning++;
+							while (!foundNonSpace && beginning < currLen ) {
+								if (message.charAt(beginning) == ' ') {
+									beginning++;
+								} else 
+									foundNonSpace = true;
+							}
+						}
+						
+						//adjust end to point to the end of the next segment
+						end = beginning + adjustedMultipleSegmentMaxSize;
+						
+						if (end >= currLen) { // at the end of the message
+							end = currLen;
+						} else if (platformData.BREAK_ON_WORD_BOUNDARIES && message.charAt(end) != ' ') { // middle of word, back up until a space is hit
+							var newEnd = end;
+							var foundSpace = false;
+							while (!foundSpace && newEnd > beginning) {
+								if (message.charAt(newEnd) == ' ') {
+									foundSpace = true;
+									end = newEnd;
+								} else {
+									newEnd--;
+								}
+							}
+						}
+						
+						if (beginning != end) {						
+							if(end != currLen)
+								result.adjustedCharacterCount += adjustedMultipleSegmentMaxSize;
+							else
+								result.adjustedCharacterCount += (end-beginning);
+							
+							result.segmentCount++;
+							if (!isCountOnly) {
+								result.segments.push(message.slice(beginning, end));
+							}
+						}
+					}
+
+					if(end != currLen || result.adjustedCharacterCount > adjustedMaxLen) { // didn't make it to the end, we are over the limit
+						result.isOverLimit = true;
+					}
+				} else {
+					result.adjustedCharacterCount = currLen;
+					result.segmentCount = 1;
+					if(!isCountOnly)
+						result.segments.push(message);
+				}
+		
+				// add headers to the front of each message segment
+				if(!isCountOnly && result.segmentCount > 1 && platformData.ADD_MESSAGE_HEADERS) {
+					for(var x=0; x<=result.segmentCount-1; x++) {
+						var header = multiMessageHeaderTemplate.evaluate({currentSegmentIndex:(x+1),lastSegmentIndex:result.segmentCount});
+						result.segments[x] = header + result.segments[x];
+					}
+				}
+
+				return result;
+			};
+			
+			var setCurrentSegmentCount = function(newSegmentCount) {
+				var displayCount;
+				if (isOverLimit) {
+					displayCount = 'X';
+					newSegmentCount = -1;
+				} else {
+					displayCount = newSegmentCount;
+				}			
+				
+				// update the segment count value if it exists
+				// Don't show the count if
+				if(segmentCounterUI.valueElement && newSegmentCount != currentSegmentCount) {
+					if(newSegmentCount != 1)
+						segmentCounterUI.valueElement.update(displayCount);
+					else
+						segmentCounterUI.valueElement.update('');	// this is not needed, but helps for testing
+				}
+				currentSegmentCount = newSegmentCount;
+				// hide/show the segment container if it exists
+				// TODO: it would be better if this fired off events
+				if(segmentCounterUI.containerElement) {					
+					if (currentSegmentCount == 1) {
+						if (segmentCounterUI.containerElement.visible()) {
+							segmentCounterUI.containerElement.hide();
+						}
+					} else {
+						if (!segmentCounterUI.containerElement.visible()) {
+							segmentCounterUI.containerElement.show();
+						}
+					}
+				}
+			};
+			
+			return {
+				
+				init: function(controller,platform,textElement,params) {
+					// defer calculating the count because we want that to fire after the events have happened
+					this.deferredResetCount = this.deferredResetCount.bind(this);
+					sceneController = controller;
+					platformType = platform;
+					
+					if(platformConst[platformType])
+						platformData = platformConst[platformType];
+					else
+						platformData = platformConst.gsm; // if we do not have platform data, use gsm by default
+					
+					textAreaElement = textElement;
+					
+					this.setParams(params);
+					
+					// This method prevents anything being entered over the maxLength + makes sure the segment count is accurate
+					this.handleKey = function(event) {
+						
+						Mojo.Log.warn("+++++keycode " + event.keyCode);
+						
+						var isControlChar;
+						
+						switch (event.keyCode){
+							case 8:
+							case 13:
+							case 16:
+							case 17:
+							case 18:
+							case 293:
+							case 294:
+							case 295:
+							case 296:
+							case 130:
+								Mojo.Log.info("special char");
+								isControlChar=true;
+								break;
+							default:
+								Mojo.Log.info("not so special")
+								isControlChar = false
+								break;
+							
+						}
+						
+						
+						if(adjustedMaxLen > 0 && isControlChar === false && adjustedCharacterCount >= adjustedMaxLen) {
+							Event.stop(event);
+							Mojo.info("past limit, blocking all non special chars")
+						}
+						
+						
+					}.bind(this);
+					
+					// we do not have access to the text being pasted in the onPaste event
+					var handlePaste = function() {
+						// parse the text field after the paste to make sure everything is ok
+						var rawCharacterData = getRawCharacterData();
+						
+						var messageData = parseMessage(rawCharacterData.message,rawCharacterData.count,true);
+						// if the length after paste is larger than the maxLength, revert the paste
+						if (adjustedMaxLen > 0 && messageData.isOverLimit) {
+							Mojo.Log.info("Reverting paste because the new length exceeds the maxLength");
+							if(setTextFieldValueFn) {
+								setTextFieldValueFn(textSavedBeforePaste);
+								textAreaElement.selectionStart = selectionStartSavedBeforePaste;
+								textAreaElement.selectionEnd = selectionEndSavedBeforePaste;
+							}
+						}
+						textSavedBeforePaste = '';
+						selectionStartSavedBeforePaste = 0;
+						selectionEndSavedBeforePaste = 0;
+						this.resetCount();
+					}.bind(this);
+					
+					this.deferredHandlePaste = function(event) {
+						// grab the text before the paste happens if we need to revert
+						textSavedBeforePaste = textAreaElement.value;
+						selectionStartSavedBeforePaste = textAreaElement.selectionStart;
+						selectionEndSavedBeforePaste = textAreaElement.selectionEnd;
+
+						// run this when the call stack becomes empty
+						handlePaste.defer();
+					};
+					
+					
+					textAreaElement.observe('keypress',this.handleKey);
+					textAreaElement.observe('keydown',this.handleKey);
+					textAreaElement.observe('paste', this.deferredHandlePaste);
+					
+				},
+				
+				destroy: function() {
+					textAreaElement.stopObserving('keypress',this.handleKey);
+					textAreaElement.stopObserving('keydown',this.handleKey);
+					textAreaElement.stopObserving('paste',this.deferredHandlePaste);
+				},
+				
+				setParams: function(params) {
+					if (params) {					
+						if(params.segmentCounter) {
+							segmentCounterUI.containerElement = params.segmentCounter.segmentCountContainer;
+							segmentCounterUI.valueElement = params.segmentCounter.segmentCountElement;
+							if(params.segmentCounter.setTextFieldValueFn) {
+								setTextFieldValueFn = params.segmentCounter.setTextFieldValueFn;
+							}						
+						}
+
+					}					
+				},
+				
+				setSizeParams: function(params) {
+					
+					Mojo.Log.info("+++++params %j ", params);
+					
+					var defaultParams = {
+						maxPartLength: 1000,
+						maxParts: 1,
+						headerSize: 0,
+						encodings: ""
+					};
+					Object.extend(defaultParams,params);
+					
+					if (defaultParams.maxPartLength) {
+						_oneSegmentMaxSize = defaultParams.maxPartLength;
+						_multipleSegmentMaxSize = (defaultParams.maxPartLength - defaultParams.headerSize);
+						_maxLength = _multipleSegmentMaxSize * defaultParams.maxParts;
+						_maxparts = defaultParams.maxParts;
+						Mojo.Log.info("+++++encodings " + defaultParams.encodings);
+						if ((params) && (!defaultParams.encodings) ||
+								(defaultParams.encodings.indexOf("UCS-2") != -1) ){
+							Mojo.Log.info("+++++supporting UCS2");
+							support2ByteChars = true;
+						}else{
+							Mojo.Log.info("+++++not supporting UCS2");
+							support2ByteChars = false;
+						}
+					} else {
+						// this should never get hit. If it does, just make sure we never go past 1000 chars
+						_oneSegmentMaxSize = 1000;
+						_multipleSegmentMaxSize = 1000;
+						_maxLength = 1000;
+						_maxparts = 1;
+						support2ByteChars = false;
+					}
+					
+					adjustedOneSegmentMaxLen = _oneSegmentMaxSize;
+					adjustedMultipleSegmentMaxSize = _multipleSegmentMaxSize;
+					adjustedMaxLen = _maxLength;
+				
+					this.resetCount();
+				},
+				
+				
+				getMaxLength: function() {
+					//return _maxLength;
+					return adjustedMaxLen;
+				},
+				
+				isValidLength: function() {
+					return !isOverLimit;
+				},
+				
+				resetCount: function() {
+					var rawCharacterData = getRawCharacterData();
+					
+					if (rawCharacterData.count > 69){
+						recheckAllTextForNonGsm = true;
+						Mojo.Log.info("text changed, looking for char size")
+					}else{
+						Mojo.Log.info("text short enough that no reason to check char size");
+					}
+					
+					var messageData = parseMessage(rawCharacterData.message,rawCharacterData.count,true);
+					adjustedCharacterCount = messageData.adjustedCharacterCount;
+					if (adjustedMaxLen > 0)
+						setOverLimit(messageData.isOverLimit);
+					setCurrentSegmentCount(messageData.segmentCount);				
+				},
+				
+				deferredResetCount: function() {
+					
+					this.resetCount.defer();
+				},
+				
+				getSegmentData: function() {
+					var rawCharacterData = getRawCharacterData();
+					var parsedMessageData = parseMessage(rawCharacterData.message,rawCharacterData.count,false);
+					
+					// The TIL will segment the message for GSM, just send one big message
+					if(platformData.RETURN_ONE_SEGMENT_ONLY && parsedMessageData.segmentCount > 1) {
+						parsedMessageData.segmentCount = 1;
+						parsedMessageData.segments = [rawCharacterData.message];
+					}
+					return parsedMessageData;		
+				}
+			}
+		}();
+		characterCounter.init(controller,platformType,textAreaElement,params);
+		Object.extend(this,characterCounter);
+	}
+});
\ No newline at end of file
diff --git a/usr/palm/applications/com.palm.app.messaging/app/views/chatview/chatview-scene.html b/usr/palm/applications/com.palm.app.messaging/app/views/chatview/chatview-scene.html
index d0d8745..fbc1f82 100644
--- a/usr/palm/applications/com.palm.app.messaging/app/views/chatview/chatview-scene.html
+++ b/usr/palm/applications/com.palm.app.messaging/app/views/chatview/chatview-scene.html
@@ -22,6 +22,10 @@
 			<div id="messageContainer" class='palm-row'>
 				<div class="palm-row-wrapper textfield-group focused">
 					<div class="title">
+						<div id="charCounterContainer" style="display: none;">
+							<div id="charCounter">
+							</div>
+						</div>
 						<div id="attachmentContainer" style="display: none;">
 							<div id="cancelAttachment">
 							</div>
diff --git a/usr/palm/applications/com.palm.app.messaging/app/views/compose/compose-scene.html b/usr/palm/applications/com.palm.app.messaging/app/views/compose/compose-scene.html
index 30daa88..aa9c440 100644
--- a/usr/palm/applications/com.palm.app.messaging/app/views/compose/compose-scene.html
+++ b/usr/palm/applications/com.palm.app.messaging/app/views/compose/compose-scene.html
@@ -6,6 +6,10 @@
 		<div id="messageContainer" class='palm-row'>
 			<div class="palm-row-wrapper textfield-group focused">
 				<div class="title">
+					<div id="charCounterContainer" style="display: none;">
+						<div id="charCounter">
+						</div>
+					</div>
 					<div id="attachmentContainer" style="display: none;">
 						<div id="cancelAttachment">
 						</div>
diff --git a/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css b/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css
index 70065e0..dcfb418 100644
--- a/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css
+++ b/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css
@@ -831,6 +831,23 @@ img.avatar-overlay {
 #messageContainer.palm-row .icon.right {
 	height: 61px;
 }
+#messageContainer #charCounterContainer {
+	line-height: 20px;
+	display:block;
+	height: 20px;
+	border-width: 0px 10px 0px 9px;
+	-webkit-border-image: url(../images/message-segment-badge.png) 0 10 0 9 stretch stretch;
+	position: absolute;
+	z-index: 3;
+	top: 2px;
+	left: 2px;
+}
+#messageContainer #charCounterContainer #charCounter {
+	font-size: 12px;
+	font-weight: bold;
+	color: #679BC2;
+	margin: 0px -4px 3px -3px;
+}
 #messageContainer #attachmentContainer {
 	position: relative;
 	margin-top:10px;
diff --git a/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css.orig b/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css.orig
new file mode 100644
index 0000000..70065e0
--- /dev/null
+++ b/usr/palm/applications/com.palm.app.messaging/stylesheets/messaging.css.orig
@@ -0,0 +1,1252 @@
+/* @override http://172.16.110.131:8888/com.palm.app.messaging/stylesheets/messaging.css */
+/*
+ * Copyright 2008 Palm Inc. Confidential until public release.
+ */
+
+/**************************************************************************************************
+ * First Launch
+ **************************************************************************************************/
+
+.palm-button.accountType {
+  text-align: left;
+}
+
+/**************************************************************************************************
+ * Add an account 
+ **************************************************************************************************/
+#preferencesHeader {
+	padding-bottom: 0px;
+}
+
+.button-icon {
+	height: 40px;
+	margin: 6px 8px 0px 0px; 
+	float:left;
+}
+
+/**************************************************************************************************
+ * Buddy List specifics
+ **************************************************************************************************/
+
+.buddyListRow .hideUnreadCount .buddy-list-unread {
+	display:none;
+}
+
+.buddyListRow .hideUnreadCount .title .truncating-text {
+	max-width:225px;
+}
+
+.buddyListRow .buddy-list-unread {
+	position:static;
+	height:auto;
+	width:auto;
+	padding: 4px -4px 0px -4px;
+	/* margin: -12px 2px; */	
+	display:inline-block;
+}
+.buddyListRow .buddy-list-unread-wrapper {
+	display:inline-block;
+/*	margin-top:-10px;*/
+}
+.buddyListRow .buddy-list-unread .pill-margin {
+	margin:0px -4px;
+}
+
+.palm-list.buddy-list .buddyListRow.hideListEntry {
+	visibility: hidden;
+}
+
+img.avatar-location {
+    right: 0px;
+    position: absolute;
+    margin: 13px 12px 0px 0px;
+}
+
+img.avatar-overlay {
+	right: 8px;
+	margin-top: 10px;
+	position: absolute;
+}
+
+.chatRow img.avatar-location {
+	margin-top: -18px;
+}
+
+.chatRow img.avatar-overlay {
+	margin-top: -21px;
+}
+
+.chatRow .avatar-container {
+	vertical-align: middle;
+	display: inline-block;
+}
+
+.login-animation-available,
+.login-animation-busy {
+  width: 26px;
+  height: 26px;
+  background: url(../images/login-animation-available.png) no-repeat;
+  position: absolute;
+  left: 0px;
+  margin: -39px 0px 0px 17px;
+}
+
+.login-animation-busy {
+  background: url(../images/login-animation-busy.png) no-repeat;
+}
+
+.buddy-list .palm-row {
+  height: 60px;
+}
+
+.buddy-list .title {
+  padding-top: 4px !important;
+  padding-right: 55px !important;
+}
+
+.history-list .title {
+  padding-top: 7px !important;
+}
+
+.buddy-list .title.hide-custom-message {
+  padding-top: 14px !important;
+}
+
+/*TODO: Temporary fix, needs to be reimplemented so as to not use a max-width*/
+.buddy-list .title:not(.hide-unread-count) .im-name-info {
+  max-width: 175px;
+	display: inline-block;
+	font-weight: bold;
+}
+
+.buddy-list .custom-message {
+  font-size: 16px;
+  padding-bottom: 2px;
+}
+
+.buddy-list .status-icon {
+  height: 59px;
+}
+
+.buddy-list .hide-unread-count .unread-count-container {
+	display: none;
+}
+
+.buddy-list .unread-count-container {
+  height: 23px;
+  border-width: 0px 11px;
+  -webkit-border-image: url(../images/unread-count-3tile.png) 0 11 0 11 repeat repeat;
+  -webkit-box-sizing: border-box;
+	display: inline-block;
+  color: #FFF;
+  font-size: 16px;
+}
+
+.buddy-list .unread-count-wrapper {
+	margin: 1px -4px 0px -4px;
+}
+
+/*background: url(../images/simple-splitter.png) bottom left repeat-x;*/
+
+#groups-list .showGroup {
+  display: block;
+}
+#groups-list .hideGroup {
+  display: none;
+}
+
+/* Used in the chat history list */
+.first-launch-icon {  
+	margin: 10px auto 15px auto;
+	width: 120px;
+	height: 120px;         
+  background: url(../images/first-launch-messaging.png) center center no-repeat;
+}                                
+
+/************************
+ /* Availability Icons
+ ************************/      
+
+#palm-popup-container .palm-list	{
+	-webkit-border-radius: 20px;
+	min-width: 260px;  /* DS: for auto, must rework support for 3 images*/
+}
+
+.status-nopresence {
+	display: block;
+	width: 32px;
+	height: 32px;
+}
+
+/* Transport picker no-status */
+.palm-popup-icon.status-nopresence {
+	width: 12px;
+	height: 48px;
+}
+
+.status-invisible {
+  width: 32px;
+  height: 32px;
+  background: url(../images/status-invisible.png) center center no-repeat;
+}
+.palm-popup-icon.status-invisible {
+  width: 12px;
+  height: 48px;
+  background-image: url(../images/status-invisible.png);
+} 
+
+.chatview-header-status.status-nopresence {
+	display:none;
+}
+
+/* STATUS PICKER ICONS */
+.palm-popup-icon.status-none {
+/*	width:30px; 
+	height:40px; */
+	margin-top:-8px;
+} 
+
+/* TRANSPORT PICKER ICONS */
+.palm-popup-icon.gmail {
+	width:40px; 
+	height:40px; 
+	background: url(../images/transports/gtalk-logo.png) center center no-repeat;
+}
+.palm-popup-icon.yahoo {
+	width:40px; 
+	height:40px; 
+	background: url(../images/transports/yahoo-logo.png) center center no-repeat;
+}
+.palm-popup-icon.aol {
+	width:40px; 
+	height:40px; 
+	background: url(../images/transports/aim-logo.png) center center no-repeat;
+}
+.palm-popup-icon.sms {
+	width:40px; 
+	height:40px; 
+	background: url(../images/transports/sms-logo.png) center center no-repeat;
+}
+                                                                                      
+
+.icon.presence-icon-button {
+	background: url(../images/status-button-up.png) center center no-repeat;
+}
+
+.icon.presence-icon-button.selected {
+	background: url(../images/status-button-down.png) center center no-repeat;
+}
+
+.presence-spinner {
+  margin: 10px 0px 0px 3px;
+}
+.presence-spinner-animation {
+  width: 32px;
+  height: 32px;
+  background: url(../images/spin_light_32x32.png) no-repeat;
+}
+
+/* This is a hack because the widget is not positioning
+ * the hint text properly
+ */
+#customMessageContainer .hint-text {
+	left: 50px;
+	color: #000;
+}
+#customMessageContainer .focused .hint-text {
+	color: #777;
+}
+
+.buddyListHeader .palm-list .icon.right {
+	height:50px;
+	width:50px;
+}
+
+.icon.right .commit-message {
+  margin-top:1px;
+  height: 50px;
+  width: 50px;
+  background: url(../images/commit-title-press.png) center center no-repeat;
+  background: url(../images/commit-title.png) center center no-repeat;
+}
+.icon.right .commit-message.selected {
+  background: url(../images/commit-title-press.png) center center no-repeat;	
+}
+/*********************
+ * Added Styles
+ *********************/
+
+/* Move the filter field down below the toggle*/
+#filterField .text-entry-filter {
+	top: 45px;
+}
+
+.buddy-list-unread {
+    /*	background: rgba(80,75,61,0.7); */
+    color: white;
+    position: absolute;
+    right: 65px;
+    font-size: 16px;
+    font-weight: normal;
+    margin: -10px 0 0 0;
+    height: 16px;
+    line-height: 16px;
+    padding: 4px -8px 0px -4px;
+    vertical-align: baseline;
+    -webkit-border-image: url(../images/unread-badge.png) 0 10 0 10 stretch stretch;
+    border-width: 10px;
+}      
+
+.palm-menu-icon.chatbuddylist {
+    background-image: url(../images/menu-icon-chatbuddylist.png);
+}
+
+.palm-menu-icon.chathistory {
+    background-image: url(../images/menu-icon-chathistory.png);
+}
+
+.palm-menu-icon.newchat {
+    background-image: url(../images/menu-icon-newchat.png);
+}
+
+.status-and-direction.icon {
+	padding-top: 5px;
+	width:31px;
+}
+
+.message-direction {
+    float: left;
+    width: 18px;
+    height: 18px;
+	margin: 0px 6px 0px 7px;
+}
+
+.title.unreadCountChatAddress {
+    font-weight: bold;
+}
+
+.buddyAvatar > img {
+    height: 48px;
+    width: 48px;
+    border: 0;
+}
+
+#myAvatar {
+    height: 34px;
+    width: 34px;
+    border: 0;
+    margin-top: 5px;
+    margin-right: 3px;
+    background-color: #999999;
+    border: 1px solid #000000;
+}              
+
+#listviewToggle {
+  position: fixed;
+  padding-left: 6px;
+  left: 0px;
+  top: 0px;
+  width: 100%;
+  background-color: #CCCCCC;
+}
+
+#listViewPadding {
+    padding-top: 50px;
+}
+
+#AvailabilityChoices {
+    position: absolute;
+    background: white;
+    top: 100%;
+    left: 0px;
+    padding-left: 3px;
+    width: 100%;
+}
+
+.availOpt {
+    width: 100%;
+    height: 50px;
+    vertical-align: middle;
+}
+
+.presenceText {
+    padding-left: 10px;
+    color: #000000;
+}
+
+.availStatus {
+    padding-top: 13px;
+}
+
+/**************************************************************************************************
+ * Chat View specifics
+ **************************************************************************************************/
+
+.chatview-header-status {
+	float: left;
+	margin: 9px -2px 0px -17px;
+}
+
+#headerChatView.palm-header #chatViewHeaderClickTarget {
+	position: fixed; 
+	top:5px; 
+	left: 5px; 
+	text-transform:none; 
+	width:200px; 
+	height:45px; 
+	z-index:5000; 
+}
+
+.chat-view-recipient-name {
+	text-transform: none;
+	padding-right: 5px;
+}
+
+.transport-picker {
+	-webkit-border-image: url(../images/messaging-selector-header-gray-press.png);
+	-webkit-border-image: url(../images/messaging-selector-header-gray.png) 0 16 0 16 stretch stretch;
+	-webkit-box-sizing: border-box;
+	border-width: 0px 16px 0px 16px;
+	font-size: 14px;
+	font-weight: bold;
+	height: 35px;
+	line-height: 35px;
+	text-transform: uppercase;
+	display: inline-block;
+	float: right;
+	margin: 8px -17px 0px 0px;
+	/*margin: 33px -17px 0px 0px;*/	
+}
+.transport-picker.selected {
+	-webkit-border-image: url(../images/messaging-selector-header-gray-press.png) 0 16 0 16 stretch stretch;
+}
+
+.transport-picker-wrapper {
+	margin: 0px -5px 0px -5px;
+}
+.transport-picker .transport-name {
+	background: transparent;
+	display: inline-block;
+	position:relative;
+	top:-1px;
+	max-width: 64px;
+	min-width: 12px;
+	overflow: hidden;
+	text-overflow: ellipsis;
+	white-space: nowrap;
+}
+.transport-picker .transport-name.disabled {
+	color: #999999;
+}
+.transport-picker .down-arrow {
+	background: url(../images/header-arrow-down.png) center right no-repeat;
+	display: inline-block;
+	float: right;
+	height: 33px;
+	width: 15px;
+	margin-top:-1px;
+	margin-left:1px;
+}
+
+#chatlist {
+  padding-bottom: 58px;
+}
+.chatRow .message .delayedMessage {
+	font-style: italic;
+	font-size: 12px;
+}
+
+
+/* This is where we style the grouped buttons */
+                                    
+.palm-menu-group .palm-menu-text {
+		top: 0px;
+		-webkit-border-image: url(../images/palm-menu-segment-middle.png) 0 25 200 25 repeat repeat;
+}
+                                                 
+.palm-menu-group .palm-menu-text:first-child {
+		-webkit-border-image: url(../images/palm-menu-segment-first.png) 0 25 200 25 repeat repeat;
+		padding-left: 5px;
+}
+                                              
+.palm-menu-group .palm-menu-text:last-child {
+		-webkit-border-image: url(../images/palm-menu-segment-last.png) 0 25 200 25 repeat repeat;
+		padding-right: 5px;
+}                                          
+                                             
+.palm-menu-group .palm-menu-text:active {
+		top: 0px;
+		-webkit-border-image: url(../images/palm-menu-segment-middle.png) 50 25 150 25 repeat repeat;
+}
+                                                       
+.palm-menu-group .palm-menu-text:first-child:active {
+		-webkit-border-image: url(../images/palm-menu-segment-first.png) 50 25 150 25 repeat repeat;
+}                                                     
+
+.palm-menu-group .palm-menu-text:last-child:active {
+		-webkit-border-image: url(../images/palm-menu-segment-last.png) 50 25 150 25 repeat repeat;
+}                                                    
+
+/* This is where we style the selected toggle buttons */
+
+.palm-menu-group .palm-menu-text.palm-depressed {
+		-webkit-border-image: url(../images/palm-menu-segment-middle.png) 100 25 100 25 repeat repeat;
+}
+
+.palm-menu-group .palm-menu-text.palm-depressed:first-child {
+		-webkit-border-image: url(../images/palm-menu-segment-first.png) 100 25 100 25 repeat repeat;
+}
+
+.palm-menu-group .palm-menu-text.palm-depressed:last-child {
+		-webkit-border-image: url(../images/palm-menu-segment-last.png) 100 25 100 25 repeat repeat;
+}                                                
+
+/* This is where we style the selected active toggle buttons */
+
+.palm-menu-group .palm-menu-text.palm-depressed:active {
+		-webkit-border-image: url(../images/palm-menu-segment-middle.png) 150 25 50 25 repeat repeat;
+}
+
+.palm-menu-group .palm-menu-text.palm-depressed:first-child:active {
+		-webkit-border-image: url(../images/palm-menu-segment-first.png) 150 25 50 25 repeat repeat;
+}
+
+.palm-menu-group .palm-menu-text.palm-depressed:last-child:active {
+		-webkit-border-image: url(../images/palm-menu-segment-last.png) 150 25 50 25 repeat repeat;
+}
+
+
+.chat-entry {
+	min-height: auto;
+	background: none;
+}
+
+.chat-entry.historyRow {
+	min-height: 80px;
+}
+
+.chat-entry .palm-row-wrapper {
+	padding: 5px 10px;
+}
+.chat-entry .chat-balloon,
+.chat-entry.their-chat .chat-balloon {
+    border-width: 10px;
+    -webkit-border-image: url(../images/chatview/chat-balloon-left.png) 10 10 10 10 stretch stretch;
+}   
+.chat-entry.selected .chat-balloon {    
+	-webkit-border-image: url(../images/chatview/empty.png) 10 10 10 10 stretch stretch;
+}                              
+.chat-entry.their-chat.error .chat-balloon {
+  -webkit-border-image: url(../images/chatview/chat-balloon-left-error.png) 10 10 10 10 stretch stretch;
+}
+.chat-entry.my-chat .chat-balloon {
+  -webkit-border-image: url(../images/chatview/chat-balloon-right.png) 10 10 10 10 stretch stretch;
+}
+.chat-entry.my-chat.error .chat-balloon {
+  -webkit-border-image: url(../images/chatview/chat-balloon-right-error.png) 10 10 10 10 stretch stretch;
+} 
+.chat-entry.my-chat.status-message .chat-balloon {
+  -webkit-border-image: url(../images/chatview/chat-balloon-right-error.png) 10 10 10 10 stretch stretch;	
+}
+
+.chat-entry .chat-balloon .chat-balloon-wrapper {
+	margin: -10px -10px -14px -10px; 
+}
+
+.chat-entry.chatRow .chat-balloon-wrapper {
+	margin: 0px;
+}
+.chat-entry .hideUnreadCount .buddy-list-unread {
+	display:none;
+}
+.chat-entry .title.truncating-text {
+	padding:0px;
+	max-width:170px;
+	display:inline-block;
+
+}
+.chat-entry .hideUnreadCount .title.truncating-text {
+	max-width:220px;
+}
+.chat-entry .buddy-list-unread {
+	position:static;
+	height:auto;
+	width:auto;
+	padding: 4px -4px 0px -4px;
+	margin: -10px 2px;
+	display:inline-block;
+}
+.chat-entry .buddy-list-unread .pill-margin {
+	margin:0px -4px;
+}
+
+.chat-entry .avatar {
+	margin: 2px 0 0 0;
+	display:inline-block; 
+	float:none; 
+	vertical-align:middle;
+}
+.chat-entry .message-container {
+	display:inline-block; 
+	width:220px; 
+	vertical-align:middle;
+}
+
+.their-chat .message-container {
+	width: 255px;
+}
+.my-chat .message-container {
+	width: 280px;
+}
+.chat-entry .chat-balloon {
+	min-height: 26px;
+}                  
+.chat-entry.my-chat.status-message {
+	font-style: italic;
+}
+.chat-entry.my-chat.status-message .messageText {
+	position:relative;
+	top:5px;
+	font-size:14px;
+}
+
+.my-chat .chat-balloon-wrapper, 
+.their-chat .chat-balloon-wrapper {
+  padding: 1px 0;
+  font-size: 18px;
+  word-wrap: break-word !important;
+}
+.their-chat .chat-balloon-wrapper {
+	padding-right: 8px;
+}
+.their-chat .avatar {
+    width: 40px;
+    height: 40px;
+}
+
+/* Disabling MY avatar because we are not doing this for 1.0  2008-11-05*/
+.my-chat .avatar-location,
+.my-chat .avatar-overlay,
+.my-chat .avatar-container {
+	display: none;
+    width: 40px;
+    height: 40px;
+}
+
+.message.status-success {
+    color: #000000;
+}
+.message.status-pending,
+.message.status-failed,
+.status-undeliverable {
+    color: #999999;
+}
+.message.priority {
+    color: #FF0000;
+}
+.messageSummary {
+  font-weight: bold;
+}
+
+.messageError .hide {
+  display: none;
+}
+
+.download-button {
+  display: none;
+}
+.status-not-yet-delivered .download-button,
+.status-retrieving .download-button {
+  display: inherit;
+}
+
+.message .callbackNumber {
+  font-style: italic;
+}
+
+.MMSImageObject {
+/*
+  max-width:240px; 
+  max-height: 300px;
+*/
+  display:block;
+  padding-top:4px;
+}
+
+.mms-attachment {
+	background-color: #CCCCCC;
+	border: 1px solid #999999;
+	height: 50px;
+	width: 100%;
+}
+
+.mms-attachment .mms-icon {
+	float:left;
+	height:48px;
+	width:48px;
+}
+
+.mms-attachment .mms-display-name {
+	float: left;
+	padding-top: 10px;
+	max-width:165px;
+}
+
+.mms-attachment .mms-size {
+	float: right;
+	padding-right: 5px;
+	padding-top: 17px;
+	font-size: 12px;
+}
+
+.mms-attachment.mms-video .mms-icon {
+	background: url(../images/mms-icon-video-new.png) center center no-repeat;
+}
+
+.mms-attachment.mms-vcard .mms-icon {
+	background: url(../images/mms-icon-vcard-new.png) center center no-repeat;
+}
+
+.mms-attachment.mms-vcal .mms-icon {
+	background: url(../images/mms-icon-vcal-new.png) center center no-repeat;
+}
+
+.mms-video.inline-progress-bar.selected .stream-background.inactive {
+  -webkit-border-image: url(../images/mini-player-bg-inactive-down.png) 8 7 6 7 repeat repeat;  
+}
+
+.filetype-icon-image.video {
+  background: url(../images/mms-icon-video-new.png) center center no-repeat;
+}
+
+.mms-image-container {
+	padding-top: 4px;
+	padding-bottom: 4px;
+}
+
+.mms-forward-placeholder {
+  margin-left: 7px;
+}
+
+.mms-forward-scrim {
+  position: absolute;
+  bottom: 0;
+  left: 7px;
+  height: 100%;
+  width: 100%;
+  background-color: rgba(228,228,226,.6);
+}
+
+.mms-forward-bottom-fade {
+	height: 54px;
+	width: 100%;
+	background: url(../images/scroll-fade-bottom.png) repeat-x;
+	position: fixed;
+	bottom: 0px;
+	left: 0px;   
+	-webkit-palm-mouse-target: ignore;
+}
+
+
+#palm-dialog-box-message #onlineTransportDialogText.show {
+  display: inline;
+}
+#palm-dialog-box-message #onlineTransportDialogText.hide {
+	display: none;
+}
+
+.popupTransportRow .status {
+  float: left;
+}
+.popupTransportRow .transportIcon {
+  float: right;
+	border: 1px solid red;
+	height: 40px;
+	width: 40px;
+}
+.progress-widget-width {
+  width: 240px;
+}
+
+.mms-audio-container {
+  height: 49px;
+}
+
+/**************************************************************************************************
+ * Chat view invitations
+ **************************************************************************************************/
+ .msg-invitation {
+ 	width: 100%;
+ 	height: 193px;
+ 	position: fixed;
+ 	bottom: 0px;
+  background-color: #e4e4e2;
+ }
+ 
+ .msg-invitation .thick-border {
+   width: 100%;
+   height: 10px;
+ 	 background: url(../images/thick-invitation-border.png) repeat-x;   
+ }
+ .msg-invitation .invitation-text {
+ 	text-align: center;
+ 	padding: 10px 0px 4px 0px;
+ 	color: #616161;
+ }
+ .msg-invitation .palm-button,
+ .msg-invitation .palm-button:active {
+  margin-bottom: 0px;
+ }
+ 
+ .msg-invitation .invitation-text .from-text {
+ 	font-size: 14px;
+ }
+
+/**************************************************************************************************
+ * Chat view text box
+ **************************************************************************************************/
+
+#messageContainer {
+	position: fixed;
+	bottom:0px;
+	left:0px;
+	width: 320px;
+}
+
+/* Force addressing widget to sit on top of
+   message body in MMS forward scene */
+.mmsforward-scene .addressing-widget {
+	position: relative;
+	z-index: 1;
+}
+
+#messageContainer #messageTextWidget {
+	margin-top: 5px;
+}
+
+#messageContainer textarea {
+	height:24px;
+}
+
+#messageContainer.palm-row .icon.right {
+	height: 61px;
+}
+#messageContainer #attachmentContainer {
+	position: relative;
+	margin-top:10px;
+}
+#messageContainer #attachmentContainer #attachmentImage {
+	max-width: 200px;
+	max-height: 100px;
+}   
+#messageContainer #attachmentContainer #cancelAttachment		{
+  width:48px; 
+  height:48px; 
+  background: url(../images/chatview/delete_picture.png) center center no-repeat;  
+  position: absolute;
+  top: -4px;
+  left: -4px;
+  padding: 3px;
+}
+
+#messageContainer #attachmentContainer #cancelAttachment.selected {
+	background: url(../images/chatview/delete_picture_press.png) center center no-repeat;
+}
+
+#ActionButton #AttachButton  {
+  /*background: url(../images/chatview/msg-attachment-paperclip.png) top left no-repeat;*/
+}
+#SendButton  {
+  /*background: url(../images/chatview/msg-send-airplane.png) top left no-repeat;*/
+} 
+
+.stuck.sendButton {
+	background: url(../images/chatview/msg-send-airplane-press.png) top left no-repeat;	
+	background: url(../images/chatview/msg-send-airplane.png) top left no-repeat;
+	width: 48px;
+	padding: 0;
+	margin: 0px;
+	height: 48px;
+	position: absolute;
+	bottom: 6px;
+	right:6px;
+}
+.stuck.sendButton.selected {
+	background: url(../images/chatview/msg-send-airplane-press.png) top left no-repeat;	
+}
+.stuck.attachButton {
+	background: url(../images/chatview/msg-attachment-paperclip-press.png) top left no-repeat;
+	background: url(../images/chatview/msg-attachment-paperclip.png) top left no-repeat;
+	width: 48px;
+	padding: 0;
+	margin: 0px;
+	height: 48px;
+	position: absolute;
+	bottom: 6px;
+	right:6px;
+}
+.stuck.attachButton.selected {
+	background: url(../images/chatview/msg-attachment-paperclip-press.png) top left no-repeat;
+}
+#ActionButton > div {
+  display:none;
+}  
+#ActionButton.empty > #AttachButton {
+  display:block;
+}
+#ActionButton.textentry > #SendButton {
+  display:block;
+}
+#ActionButton.invisible {
+  visibility: hidden;
+}	  
+		
+#ActionButton #SendButton #segmentCounterContainer {
+    line-height: 20px;
+	display:block;
+	height: 20px;
+	border-width: 0px 10px 0px 9px;
+	-webkit-border-image: url(../images/message-segment-badge.png) 0 10 0 9 stretch stretch;
+	position: absolute;
+	z-index: 3;
+	bottom: 0;
+	right: -2px;
+}
+#ActionButton #SendButton #segmentCounterContainer #segmentCounter {
+	font-size: 12px;
+	font-weight: bold;
+	color: #679BC2;
+	margin: 0px -4px 3px -3px;
+/*	padding-left: 2px;*/
+/*	padding-top: 3px;*/
+} 		
+#ActionButton #SendButton #segmentCounterContainer #segmentCounter.overLimit {
+	color: #FF0000;
+}
+
+.messageTextWidget {
+	overflow: hidden; 
+	max-height: 220px; /*HACK: We need a different way to limit the max height so that this is compatible across devices with different screen sizes*/
+}
+
+/**************************************************************************************************
+ * List Section Labels, date stamp-style
+ **************************************************************************************************/
+.date-stamp-label {          
+    margin-left: 0
+	margin-right: 3px;             
+    height: 32px;               
+    border-collapse: collapse;
+}
+.date-stamp-label .left {
+    width: auto;
+    white-space: nowrap;
+    background: url(../images/chatview/date-stamp-line.png) right no-repeat;
+    padding-left: 8px;
+}                      
+
+.date-stamp-label .label {   
+	color: #ababaa;
+	text-shadow: #fff 0px 1px 0px;     
+	font-size: 16px;
+	line-height: 32px;
+	font-weight: bold;             
+    text-transform: uppercase;       
+    white-space: nowrap;
+}
+.date-stamp-label .label.sms {
+    padding-left: 36px;
+    background: url(../images/transports/transport-sms-32x32.png) left no-repeat;
+}
+.date-stamp-label .label.aol {
+    padding-left: 36px;
+    background: url(../images/transports/transport-aol-32x32.png) left no-repeat;
+}                                                                                
+.date-stamp-label .label.gmail {
+    padding-left: 36px;
+    background: url(../images/transports/transport-gmail-32x32.png) 2px no-repeat;
+}
+.date-stamp-label .label.yahoo {
+    padding-left: 36px;
+    background: url(../images/transports/transport-yahoo-32x32.png) left no-repeat;
+}                         
+
+.date-stamp-label .right {
+    width: 100%;
+    padding-right: 8px;
+    background: url(../images/chatview/date-stamp-line.png) left no-repeat;
+}                                      
+
+
+/***********************************************
+ * Preferences Specific
+ * *********************************************/  
+                                                                     
+
+.text-group {
+/*	padding: 10px 0px 10px 10px;
+*/}
+.text-group .title {                     
+	line-height: auto !important;
+	padding: 0 !important;
+	margin-right: -4px;   
+}                      
+               
+.prefs-account-name-disabled {
+  color: #EEE;
+}
+
+.icon.messaging-app {
+	background-image: url(../images/header-icon-messaging.png) !important;
+}
+
+.icon.account-image {
+	background: none !important;
+	padding-top: 6px;
+	padding-left: 8px;
+}	   
+
+.domain-text {
+	font-size: 18px;
+	padding-top: 5px;
+}
+.number-text{
+	font-size: 18px;
+	padding-top: 13px;
+}
+.login-text{
+	font-size: 14px;
+	color: #999;
+}
+.selected .domain-text,
+.selected .login-text {
+	color: #fff;
+}
+/* Prefs Extra Content for AIM*/
+.extra-content .title {
+	float: left;
+	padding: 0px 0px 0px 15px;	
+}
+
+.extra-content .link-globe {
+	background: url(../images/link-globe.png) center center no-repeat;
+	height: 40px;
+	width: 29px;
+}
+
+.list-selector-container {
+	height: 42px;
+	float: right;
+	border-width: 0px 11px;
+	-webkit-box-sizing: border-box;
+	-webkit-border-image: url(../images/list-selector-border-image-downstate.png) 0 11 0 11;
+	-webkit-border-image: url(../images/list-selector-border-image.png) 0 11 0 11;
+	margin-top: 5px;
+	margin-right: 5px;
+}
+
+.list-selector-container.selected {
+	-webkit-border-image: url(../images/list-selector-border-image-downstate.png) 0 11 0 11;
+}
+
+.list-selector-wrapper {
+  margin: 0px -5px;
+}
+
+/**************************************************************************************************
+ * Notifications & Dashboard
+ **************************************************************************************************/ 
+
+.image-mask img {   
+	width: 34px;
+	height: 34px;
+}
+
+.image-mask {
+	width: 34px;
+	height: 34px;
+	overflow: hidden;
+	position: absolute;
+	right: 7px;
+	margin-top: 7px;
+}
+
+.image-overlay {
+	width: 47px;
+	height: 50px;
+	background: url(../images/image-overlay-border-dash.png) center center no-repeat;
+	position: absolute;
+	right: 0px;
+	margin-top: 0px;
+}
+
+.image-overlay-attachment {
+	width: 47px;
+	height: 50px;
+	background: url(../images/messaging-attachment-clip.png) center center no-repeat;
+	position: absolute;
+	right: 0px;
+	margin-top: 0px;
+}
+
+.dashboard-newitem span,
+.palm-dashboard-text-container {	
+	font-size: 16px;
+}
+
+.dashboardIcon {
+  width: 50px; 
+  height: 50px; 
+  float: left;
+}
+
+.dashboardMMSImage {
+  width: 42px;
+  height: 42px;
+  margin-top: 3px;
+  margin-bottom: 3px;
+  margin-right: 2px;
+  float: right;
+  overflow:hidden;
+  background-position:center center;
+  background-repeat:no-repeat;
+  -webkit-background-size:42px auto;
+}
+
+.dashboardMMSImage.hidden {
+  display: none;
+}
+
+.dashboardContentContainer .dashboardTopLine {
+  font-weight:bold; 
+  padding-top:4px;
+}
+.dashboardContentContainer .dashboardBottomLine {
+}
+
+.dashboardContentContainer {
+  padding-left: 2px;
+}
+
+.palm-dashboard-text-container .palm-dashboard-text {
+	max-width:200px;
+	overflow: hidden;
+	text-overflow: ellipsis;
+}
+
+/*****************************************
+ * Statuses in dashboard
+ *****************************************/
+.dashboard-title {
+	height:20px;
+	max-width:200px;
+}
+
+.dashboard-title .topLine{
+	float:left;
+	max-width:176px;
+	overflow: hidden;
+	text-overflow: ellipsis;
+}
+
+.dashboard-title .presence{
+	float:left;
+	width: 24px;
+	height: 24px;
+}
+
+.palm-dark .status-available {
+  background: url(../images/status-available-dark.png) center center no-repeat;
+}
+.palm-dark .status-available.partial {
+  background: url(../images/status-available-partial-dark.png) center center no-repeat;
+}
+.palm-dark .status-away {
+  background: url(../images/status-away-dark.png) center center no-repeat;
+}
+.palm-dark .status-busy {
+  background: url(../images/status-busy-dark.png) center center no-repeat;
+}
+.palm-dark .status-busy.partial {
+  background: url(../images/status-busy-partial-dark.png) center center no-repeat;
+}
+.palm-dark .status-idle {
+  background: url(../images/status-idle-dark.png) center center no-repeat;
+}
+.palm-dark .status-offline {
+  background: url(../images/status-offline-dark.png) center center no-repeat;
+}
+                       
+.hinted {
+  color:gray;
+}
+/* 
+.TextAreaShill {
+  position:absolute;
+  visibility:hidden;
+  z-index:0;
+  top:-500px;
+  max-height: 200px;
+  word-wrap:break-word;
+}
+*/
+/*****************************************
+ * Full Screen Image View
+ *****************************************/
+#imageViewMain #imageViewSave {
+	position: fixed; 
+	bottom:0;
+	left: 0;
+	right: 0;
+}
+
+/*****************************************
+ * Dashboard Icon Style
+ *****************************************/
+ .palm-dashboard-icon.messaging.single	{ background: url(../images/notification-large-messaging.png) center left no-repeat; }
+ .palm-dashboard-icon.messaging.multi	{ background: url(../images/notification-large-messaging-mult.png) center left no-repeat; }
+
+
+
+.has-im-account .filter-field-container {
+	z-index: 11000;
+}
+.has-im-account .filter-field-container.filter-field-container-height {
+	height:94px;
+}
+#buddyListContainer .palm-page-header {
+	position:absolute;
+	top:0px;
+	width:100%;
+}
+#buddyListContainer .palm-page-header .spacer {
+	height:50px;
+	width:100%;
+}
+.listview-presence-section {
+	background-color: #C5C5C5; 
+	width:100%; 
+}
+
+.has-im-account .palm-menu-spacer {
+	height:50px !important;
+}
+.has-im-account .palm-menu.view-menu.palm-default {
+	top:0px !important;
+}
+
+.palm-dashboard-icon.personal-reminder {
+	background:url(../images/personal-reminder-notification.png) center center no-repeat;
+}
+.personal-reminder-icon-small {
+	background:url(../images/personal-reminder-icon-small.png) center center no-repeat;
+}
+#im-links .palm-row .title {
+	padding: 9px 14px;
+}
+
+
+.list-view,
+.history-list {
+	height: 100%;
+}
\ No newline at end of file
